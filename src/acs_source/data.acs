
////////////////////////////////////
//  	General settings		   //
////////////////////////////////////

#DEFINE CVAR_AUTOLOGIN "C8_autologin"



////////////////////////////////////
//  	Runtime settings		   //
////////////////////////////////////

#DEFINE CVAR_HERO_SIZE "C8_hero_size"
function int getHeroSize(void) { 				        	    	return GetCvar(CVAR_HERO_SIZE); }

#DEFINE CVAR_HERO "C8_hero_"
function int getHeroFromIndex(int index) { 				        	return get8bFlagVal(CVAR_HERO, true, index); }
function void setHeroFromIndex(int index, int heroId) {				set8bFlagVal(CVAR_HERO, true, index, heroId); }

#DEFINE CVAR_LOGIN "C8_login_"
function str getLogin(int player) { 								return strSanitize(GetCvarString(__login(player))); }
function void setLogin(int player, str login) { 					SetCVarString(__login(player), login); }
function str __login(int player) { 									return strParam(s:CVAR_LOGIN, d:player); }
function bool isLoggedIn(int player) { 								return isNetworkGame() && strLen(getLogin(player)); }

#DEFINE CVAR_SLOT "C8_slot"
// return -1 for quick play, 0 and 1 for account slots
function int getSlot(int player) { 									return get2bFlagVal(CVAR_SLOT, false, player)-1; }
function void setSlot(int player, int val) { 						set2bFlagVal(CVAR_SLOT, false, player, val+1); }

#DEFINE CVAR_PLAYER_HERO "C8_player_hero_"
function int getPlayerHero(int player, int slot) { 					return get8bFlagVal(__playerHero(player,slot), true, player)-1; }
function void setPlayerHero(int player, int slot, int val) { 		set8bFlagVal(__playerHero(player,slot), true, player, val+1); }
function bool isSlotEmpty(int player, int slot) {                   return getPlayerHero(player,slot) == -1; }
function str __playerHero(int player, int slot) { 					return strParam(s:CVAR_PLAYER_HERO, d:slot+1); }

#DEFINE CVAR_EXP "C8_exp_"
function int getExp(int player, int slot) {							return GetCvar(__exp(player,slot)); }
function void setExp(int player, int slot, int exp) {				SetCVar(__exp(player,slot), exp); }
function str __exp(int player, int slot) {							return strParam(s:CVAR_EXP, d:slot+1, d:player); }

#DEFINE CVAR_WEP_UNLOCKED "C8_wep_unlocked_"
function bool getWepUnlocked(int player, int slot) {				return GetCvar(__wepUnlocked(player,slot)); }
function void unlockWeapon(int player, int slot, int wepId) {
	str cvar = __wepUnlocked(player,slot); 
	SetCVar(cvar, GetCvar(cvar) | (1 << wepId));
}
function void setWepUnlocked(int player, int slot, int weps) {		SetCVar(__wepUnlocked(player,slot), weps); }
function str __wepUnlocked(int player, int slot) {					return strParam(s:CVAR_WEP_UNLOCKED, d:slot+1, d:player); }



////////////////////////////////////
//  Hero/enemy specific fields    //
////////////////////////////////////

// Those need getHeroFromIndex to transform the runtime id (array of heroes loaded) into the cvar-defined hero ID

function str getHeroActor(int index) {								return GetCvarString(strParam(s:"C8_hero_actor_", d:getHeroFromIndex(index))); }

function str getHeroName(int index) {								return GetCvarString(__heroName(getHeroFromIndex(index))); }
	function str __getHeroName(int heroId) {						return GetCvarString(__heroName(heroId)); }
	function str __heroName(int heroId) {							return strParam(s:"C8_hero_name_", d:heroId); }
function int getHeroHP(int index) {									return GetCvar(strParam(s:"C8_hero_hp_", d:getHeroFromIndex(index))); }
function int getHeroPuissance(int index) {							return GetCvar(strParam(s:"C8_hero_puissance_", d:getHeroFromIndex(index))); }
function int getHeroWeapons(int index) {							return GetCvar(strParam(s:"C8_hero_weapons_", d:getHeroFromIndex(index))); }
function int getHeroWeaponGroups(int index) {						return valueOr(GetCvar(strParam(s:"C8_hero_weapon_groups_", d:getHeroFromIndex(index))),1); }
function str getSpSkill(int index) {								return GetCvarString(strParam(s:"C8_sp_skill_", d:getHeroFromIndex(index))); }
function str getHeroText(int index) {								return GetCvarString(strParam(s:"C8_hero_text_", d:getHeroFromIndex(index))); }

function str getHeroMugshot(int index) {							return __getHeroGraphic(index,0); }
function str getHeroIdle(int index) {								return __getHeroGraphic(index,1); }
function str getHeroSelected(int index) {							return __getHeroGraphic(index,2); }
function str __getHeroGraphic(int index, int shift) {
	str base = __heroGraphic(index);
	if (shift)
		base = strRight(base, strLen(base)-(shift*9));
	return strLeft(base, 8);
}
function str __heroGraphic(int index) { 							return GetCvarString(strParam(s:"C8_hero_graphic_", d:getHeroFromIndex(index))); }



// testers
script "seto" (int i, int j) { setSlot(i,j); delay(1); log(d:getSlot(i)); }
script "geto" (int i) { log(s:getHeroName(i)); }




//////////////////////
// Database schema  //
//////////////////////

#DEFINE DB_FIELD_HERO_ID "player_hero_"
#DEFINE DB_FIELD_WEAPON "weapon_"
#DEFINE DB_FIELD_EXP "exp_"








/////////////////
//  Constants  //
/////////////////

#DEFINE INT_MAX 0x7fffffff
#DEFINE INT_MIN 0x80000000

#DEFINE MAX_HERO 256
#DEFINE MAX_CLIENTS 16
// -1 value is used to refer to quick play slot
#DEFINE MAX_SLOTS 2
#DEFINE MAX_WEAPON_GROUPS 4


#DEFINE MENU_UP (BT_FORWARD)
#DEFINE MENU_DOWN (BT_BACK)
#DEFINE MENU_LEFT (BT_LEFT|BT_MOVELEFT)
#DEFINE MENU_RIGHT (BT_RIGHT|BT_MOVERIGHT)
#DEFINE MENU_YES (BT_ATTACK)
#DEFINE MENU_NO (BT_ALTATTACK)

#DEFINE SMALL_FONT 0
#DEFINE BIG_FONT 1

#DEFINE HUD_ID 1

#DEFINE DEFAULT_HUD_X 320
#DEFINE DEFAULT_HUD_Y 200





/////////////////
//  Runtime   //
/////////////////

// Used for title screen and weapon selection
#DEFINE MENU_COMMON 0
#DEFINE MENU_INDEX 1
#DEFINE MENU_STATE 2 // 1+2

int client_menuStatus[5] = { 0, 0, 0, 0, 0 };
function int getMenu(void) { 					return client_menuStatus[MENU_COMMON]&0xFF; }
function void setMenu(int val) { 				client_menuStatus[MENU_COMMON] = (client_menuStatus[MENU_COMMON]&0xFFFFFF00)|val; }
function int getMenuTransition(void) { 			return ((client_menuStatus[MENU_COMMON])>>8)&0xFF; }
function void setMenuTransition(int val) { 		client_menuStatus[MENU_COMMON] = (client_menuStatus[MENU_COMMON]&0xFFFF00FF)|(val<<8); }
function int getMenuRefresh(void) {				return ((client_menuStatus[MENU_COMMON])>>16)&0xFF; }
function void setMenuRefresh(int val) {			client_menuStatus[MENU_COMMON] = (client_menuStatus[MENU_COMMON]&0xFF00FFFF)|(val<<16); }
function bool getMenuQuery(void) {				return ((client_menuStatus[MENU_COMMON])>>24)&0xFF; }
function void setMenuQuery(int val) {			client_menuStatus[MENU_COMMON] = (client_menuStatus[MENU_COMMON]&0x00FFFFFF)|(val<<24); }
function int getMenuIndex(void) {				return client_menuStatus[MENU_INDEX]; }
function void setMenuIndex(int val) {			client_menuStatus[MENU_INDEX] = val; }
// arg [0,2]
function int getMenuArg(int arg) {				return client_menuStatus[MENU_STATE+arg]; }
function void setMenuArg(int arg, int val) {	client_menuStatus[MENU_STATE+arg] = val; }

function bool inMenu(void) {					return !!getMenu(); }
function void resetMenu(void) {					for (int i=0; i < 5; i++) client_menuStatus[i] = 0; }

// function void menuStatusReset(void) { for (int i = 0; i < 8; i++) setMenu(i,0); }
// function bool inMenu(void) { return !!getMenu(MENU_NOW); }





/*
    type in console
	pukename hude
	to test this tool. To change the graphic being displayed, type the graphics' name in chat

- Movement key						change position/scale (hold fire to speed up)
- Reload							toggle position/scale mode
- Show scoreboard 					toggle "keep graphic proportions"
- Altfire							stamp the image (can stamp up to 64 images on screen)
- Altfire (while holding Fire)		delete the last stamped image
- Reload (while holding Fire)		show all current's stamps' coordinates			
*/

str hude_graphic = "CHINTR2";
script "hude" (void) CLIENTSIDE {
	int x = 0, y = 0, sizeX = 320, sizeY = 200;
	str stamps[64]; int maxStamp = 64;
    int inp, oldB, incr, id = 0;
    bool mode, delta, speedUp, proportional = 1;
    int decimals;
    int ratio = 1.6;
	SetPlayerProperty(0,1,PROP_TOTALLYFROZEN );
    do {
        inp = GetPlayerInput(-1, INPUT_BUTTONS);
		oldB = GetPlayerInput(-1, INPUT_OLDBUTTONS);
		str coords = strParam(s:"\c->>> [ \cc", s:hude_graphic, s:"\c- ] \cax = ", f:X, s:" \ciy = ", f:Y, s:"   \ckSizeX = ", d:sizeX, s:" \cdSizeY = ", d:sizeY);

		if (!(oldB&(BT_ATTACK) && oldB&(BT_RELOAD)) && (inp&(BT_ATTACK) && inp&(BT_RELOAD))) {
			for (int i = 0; i < id; i++)
				log(s:stamps[i]);
			LocalAmbientSound("misc/trainwhistle", 127);
		}
        else if ((!(oldb&BT_RELOAD) && (inp&BT_RELOAD)) && !(inp&BT_ATTACK)) {
            mode = !mode;
            LocalAmbientSound("misc/10w3elvs",127); 
            log(s:"Mode : ", s:mode ? "\cnscale" : "\caposition");
        }

		else if (!(oldB&(BT_ATTACK) && oldB&(BT_ALTATTACK)) && (inp&(BT_ATTACK) && inp&(BT_ALTATTACK))) {
			if (id) {
				stamps[id] = "";
        		HudMessageBold(s:""; HUDMSG_PLAIN , maxStamp-id,CR_UNTRANSLATED, x, y, 0, 1.0);
				id--;
				LocalAmbientSound("item/rushdetect", 127); 				
			}
		}
		else if (!(oldB&(BT_ALTATTACK)) && (inp&(BT_ALTATTACK))) {
			if (id == maxStamp-1) {
				Log(s:"\cgCan't stamp!! ", d:maxStamp, s:" limit reached");
				LocalAmbientSound("misc/boing", 127);
			}
			else {
				stamps[id] = strParam(s:"--- \ccStamped ", s:coords);
				id++;
				LocalAmbientSound("misc/mercuryconveyorswitch", 127);
			}
		}
        if (!(oldb&BT_SHOWSCORES) && (inp&BT_SHOWSCORES)) {
            proportional = !proportional;
            if (proportional)
                ratio = FixedDiv(sizeX<<16, sizeY<<16);
			LocalAmbientSound("misc/sheepblockreturn", 127);
            log(s:"Keep proportions : ", s:proportional ? "\cdyes" : "\cqNO");
        }
        speedUp = inp&BT_ATTACK;
        if (!mode) incr = 1.0 * (speedUp ? 6 : 1);
        else       incr = 1 * (speedUp ? 8 : 1);
        delta = 0;
        if(!mode) {
            if  (inp&BT_MOVELEFT)   { x-=incr; delta = true; }
            if  (inp&BT_MOVERIGHT)  { x+=incr; delta = true; }
            if  (inp&BT_FORWARD)    { y-=incr; delta = true; }
            if  (inp&BT_BACK)       { y+=incr; delta = true; }
        }
        else {
            if (!proportional) {
                if  (inp&BT_MOVELEFT)   { sizeX+=incr; delta = true; }
                if  (inp&BT_MOVERIGHT)  { sizeX-=incr; delta = true; }
                if  (inp&BT_FORWARD)    { sizeY+=incr; delta = true; }
                if  (inp&BT_BACK)       { sizeY-=incr; delta = true; }
            }
            else {
                if (inp&(BT_MOVERIGHT|BT_BACK)) incr *= -1;
                else if (!(inp&(BT_MOVELEFT|BT_FORWARD))) incr = 0;
                if (incr) {
                    int plusX = ratio*incr;
                    decimals += plusX&0xFFFF;
                    if(decimals>>16) {
                        plusX += (decimals&0xFFFF0000); decimals &= 0xFFFF;
                    }
                    plusX>>=16;
                    sizeX += plusX; 
					sizeY += incr; 
					delta = true;
                }
            }
        }
        if (delta)
            log(s:coords);
        delay(1);
		SetHudSize(sizeX,sizeY,true);
		SetFont(hude_graphic);
        HudMessageBold(s:"A"; HUDMSG_PLAIN , maxStamp-id,CR_UNTRANSLATED, x, y, 0, 1.0);
			
    } while (true);
}

script "hude_chat" (int type, int arg1, int arg2) EVENT {
	if (type==GAMEEVENT_CHAT)
		hude_graphic = GetChatMessage(arg1,0);
}
