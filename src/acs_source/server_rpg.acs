

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ RPG-like system/stats/game progress related behavior  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //


script "8C RPG" (int type, int arg1, int arg2, int arg3) {
	switch(type) {
		/* no args */
		case RPG_INCARNATE:
			if (!isMap8C) 
				terminate;
			int player = PlayerNumber();
			arg1 = getAllowedSlot(player);
			if (isSlotEmpty(player,arg1)) {
				KickFromGame(player, "\ckYou first have to create a \cvhero\ck to join the game");
				terminate;
			}
			int entity = getPlayerHero(player,arg1);
			arg2 = getHeroActor(entity);
			MorphActor(0, arg2,
				"", 0x7FFFFFFF, MRF_WHENINVULNERABLE|MRF_FULLHEALTH|MRF_FAILNOLAUGH|MRF_NEWTIDBEHAVIOUR, "gfx", "gfx");
			GiveInventory("BaseFlagPack",1);
			GiveInventory(StrParam(s:arg2, s:" onSpawn"), 1);
			GiveInventory("8C ID", entity);
			updateRank(getRank(player,arg1), true);
			GiveInventory("NoHud",1);
			ACS_NamedExecuteWithResult("8C CS", CS_INGAME_HUD);
		break;

		/*
		@arg1 enemy's CVARINFO (static/compile time) ID
		@arg2 map spot TID
		*/
		case RPG_SUMMON_ENEMY:
			entity = getEnemyName(arg1);
			arg3 = UniqueTID();
			type = SpawnSpotFacingForced(entity, arg2, arg3);
			if (!type) {
				Log(l:"8C_ENEMY_UNDEFINED", s:"\cc(ID \ca", d:arg1, s:"\cc, on spot \ca", d:arg2, s:"\cc)");
				terminate;
			}
			SetActivator(arg3);
			if (!arg2) 
				Setactorposition(0,GetActorX(0)+128.0,GetActorY(0),GetActorZ(0),false);
			GiveInventory("8C ID", arg1);
			arg1 = random(5,5);
			updateRank(arg1,true); // monsters max/"spawn" hp can't be modified at current time zandro versions
		
			if (!random(0,1024))
				GiveInventory("8C Shiny", 1);
			SetUserVariable(0,ENEMY_COLOR_USERVAR,-1);
			enemyPalette();
			Thing_ChangeTID(0, 0);
			Log(s:"\cnspawned \cc(\ci", s:entity, s:"\cc, rank \ci", d:arg1, s:"\cc)");
		break;
	}
}



function int damageCalculation(int damage) {
	if (!isMap8C | (damage>>14)) // if suicide/telefrag etc
		return damage;
   	damage<<=16;

	// Puissance
		int puissance = puissanceCalculation(true);
		damage = FixedMul(damage/100,puissance<<16);
	// +/- 15% RNG
		int fluctuation = 1.0 + (0.05*random(0,3)); // +/- 15%
		damage = random(0,1) ? FixedMul(damage,fluctuation) : FixedDiv(damage,fluctuation);
	// Debug
		SetActivator(0, AAPTR_DAMAGE_SOURCE);
		int strBuild = strParam(s:"\ca[", f:FixedDiv(Timer(),35), s:"] \c-", n:0, s:" \ccRANK \ck", d:getActorRank(), s:" \caPui ", d:puissance);
		SetActivator(0, AAPTR_DAMAGE_TARGET);
		strBuild = strParam(s:strBuild,s:"\cc --> ", n:0, s:" -\ci", f:damage);
		log(s:strBuild);
	
	// Decimal resolve
		damage = storeDecimalHP(damage);	

    return damage;
}

// round damage dealt to integer, and store decimal part on the victim actor's inventory
function int storeDecimalHP(int val) { // int isHeal
	SetActivator(0, AAPTR_DAMAGE_TARGET);
	if (!(val&0xFFFF))
		return val>>16;
	int decimalPoints = CheckInventory("8BDM HP");
	TakeInventory("8BDM HP", 0x1FFFF);
	if (decimalPoints & 0x10000)
		val += (decimalPoints & 0xFFFF);
	else
		val -= (decimalPoints & 0xFFFF);
	int rounded = roundf(val);
	if (rounded<val)
		GiveInventory("8BDM HP", (0x10000) | (val-rounded));
	else
		GiveInventory("8BDM HP", 			 (rounded-val));
	//if (CheckInventory("8BDM HP")&0x10000) 	log(s:"[ HP - ", f:CheckInventory("8BDM HP")&(0xFFFF), s:" ]"); 
	//else										log(s:"[ HP + ", f:CheckInventory("8BDM HP")&(0xFFFF), s:" ]"); 
	return rounded>>16;
}

// ---------------------------------- the holy linear function stat calc ------------------------------------------------- //
function int calcPerRank(int base, int rank) { return base + ((roundf(FixedMul(0.142857142*(rank-1),base<<16)))>>16); }
// ----------------------------------------------------------------------------------------------------------------------- //
function int puissanceCalculation(bool source) {
	if (source)			SetActivator(0, AAPTR_DAMAGE_SOURCE);
	return calcPerRank(isEnemy() ? getEnemyPuissance(getActorID()) : getHeroPuissance(getActorID()), getActorRank());
}
function int hpCalculation(void) { 
	return max(1, calcPerRank(isEnemy() ? getEnemyResilience(getActorID()) : getHeroResilience(getActorID()), getActorRank())); 
}

#DEFINE EXP_REDUCTION_PER_RANK 20
function void enemyExpGain(int id, int rank) {
	int shares = getSelectedPlayers();
	int shift = (shares-1)/2; // purpose is to work with bigger numbers to reduce accuracy loss when dividing
	int base = (calcPerRank(getScore(id), rank)<<shift)/shares;
	log(s:" +\ci", d:base, s:"\cc among \ci ", d:shares);
	for (int player = 0; player < MAX_C8_PLAYERS; player++)
		if (PlayerInGame(player) && isSelectedPlayer(player)) {
			int playerExp = getExp(player,getAllowedSlot(player));	
			int pendingExp = playerExp + getExpPool(player);
			int remaining = base;
			while (true) { // handles cases where exp gain cross to next ranks
				int reduction = (((((expToRank(pendingExp)-1)*EXP_REDUCTION_PER_RANK)*remaining)/base)/shares);
				int exp = max(0, (remaining>>shift) - reduction);
				int toRankUp = 1000 - (pendingExp%1000);
				if (exp < toRankUp) {
					SetActivatorToPlayer(player);
					int prevpool= getExpPool(player);
					setExpPool(player, pendingExp-playerExp+exp);
					log(s:"   ", n:0, s:" +", d:getExpPool(player)-prevpool, s:"");
					break;
				}
				else {
					remaining = (exp-toRankUp)<<shift;
					pendingExp += toRankUp;
				}
			}
		}
}

function void enemyPalette(void) {
	int color = GetUserVariable(0,ENEMY_COLOR_USERVAR);
	Thing_SetTranslation(0, (color>=0) ? color : ENEMY_COLOR+(getActorID()*ENEMY_COLOR_SIZE)+isShiny());
}

function void updateRank(int rank, bool fillHp) {
	SetInventory("8C Rank", rank);
	rank = hpCalculation();
	SetActorProperty(0,APROP_SpawnHealth,rank);
	if (fillHp) SetActorProperty(0,APROP_Health,rank);
}