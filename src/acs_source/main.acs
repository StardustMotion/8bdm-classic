


	

	//////////////////////////////////////////////////////////
//                           Events             				//
	//////////////////////////////////////////////////////////
    
script "8C OPEN" OPEN {
	init();
}

bool forcePhysics, isMap8C;
function void init(void) {
	forcePhysics = GetCvar("C8_physics");
	isMap8C = !strCmp(strLeft(strParam(n:PRINTNAME_LEVEL), 3),"8C-");

    if (!getHeroSize()) {
        for (int i = 0, heroCount = 0; i < MAX_HERO; i++)
            if (strLen(strSanitize(__getNiceName(i)))) {
                setHero(heroCount, i);
                heroCount++;
            }
        SetCVar(CVAR_HERO_SIZE, heroCount);
    }

	if (isMap8C || forcePhysics) {
		for (i = 0; i < 512; i++) 
			Sector_SetFriction(i,-96);
		DefinePowerAprop("8C Static Move Giver", "8C Static Move", APROP_Speed, 16.0, false);
		DefinePowerAprop("8C On actor gravity Giver", "8C On actor gravity", APROP_Gravity, 0.0, false);
	}

	if (isMap8C) {
		ConsoleCommand(strParam(s:"sv_maxclients ", d:min(GetCvar("sv_maxclients"), MAX_CLIENTS))); // GAMEMODE
		ConsoleCommand("mm8bdm_sv_respawnprotection 0"); // side effect / need a hook
	}
}
    
    
	//////////////////////////////////////////////////////////
//                           Core                				//
	//////////////////////////////////////////////////////////

#DEFINE NET_START_SCREEN 256
#DEFINE START_SCREEN 257
    #DEFINE START_SCREEN_TITLE 0
    #DEFINE START_SCREEN_DATA 1
    #DEFINE START_SCREEN_CREATE_HERO 2
    #DEFINE START_SCREEN_OPTIONS 3
    #DEFINE START_SCREEN_ENTER_GAME 4

script "8C NET CS" (int type) NET CLIENTSIDE {
	switch(type) {
		case NET_START_SCREEN:
			if (!inMenu() && PlayerIsSpectator(PlayerNumber()))
				ACS_NamedExecuteWithResult("8C CS", START_SCREEN);
		break;
	}
}

script "8C CS" (int type, int arg1, int arg2, int arg3) CLIENTSIDE {
	int localPlayer = ConsolePlayerNumber();
    switch(type) {
		case START_SCREEN:
			loginPoll(localPlayer);
			int delta = 0;
			for (int i = 0; i < 16; i++) {
				drawBI("8CTITLTR",-32.0 + 2.0*i, 8.0, 16,  16);
				drawBI("8CTITLTR", 48.0 -2.0*i	, 9.0, 16, 16);
				delay(1);
			}
			delta = 0;		
			LocalSetMusic("8CDATA");
			arg1 = 0;
			setMenu(START_SCREEN_TITLE);
			int status = getMenu();
			int fade = 8;
			while (fade < 9) {
				draw("8CTITLBL", false, 0, 0, 1, 1, 0.05, FixedDiv(fade<<16,8.0));
				
				if (!inMenu())  fade++;
				else if (fade)  fade--;

				// if (inMenu())
                //     arg2 = startScreen(arg1);

				if (arg1 != arg2) {
					LocalAmbientSound("menu/cursor", 120); 
					arg1 = arg2;
				}
				if (status != getMenu()) {
					LocalAmbientSound("misc/introstardroiddash", 120);
					fade = 0; 
					status = getMenu();
					if (!inMenu()) 
						continue;
					arg1 = 0;
					delay(15);
				}
				for (int picX = 0; picX < 7; picX++) {
					for (int picY = 0; picY < 4; picY++) {
						drawSBI("8CTITLBG", 
								-96.0 + ((delta*80)&0xFFFF0000) + 80.0*picX, 
								-64.0 + ((delta*96)&0xFFFF0000) + 96.0*picY);
					}
				}
				delta = (delta+512)&0xFFFF;
				delay(1);
				if (getMenu() == START_SCREEN_ENTER_GAME) break;
			}

			for (i = 16; i >= 0; i--) {
				drawBI("8CTITLTR",-32.0 + 2.0*i, 8.0, 16,  16);
				drawBI("8CTITLTR", 48.0 -2.0*i	, 9.0, 16, 16);
				delay(1);
			}
			LocalSetMusic("*");

            setMenu(-1);
			// --
			// if (menuStatus == START_SCREEN_ENTER_GAME) {
			// 	consolecommand("menu_joingame");
			// }
		break;

    }
    
}


// // weird design pattern XD? ?
// function int startScreen(int state) {
// 	int base = 60.0;
// 	int back = 160.0;
// 	int player = PlayerNumber();
// 	int index;
//     int menu = getMenu();

// 	switch(menu&0xFF) {
// 		case START_SCREEN_TITLE:
// 			bool isLocalLogged = isLogged(player);
// 			bool isFirstHero = !hasHero(player,false);

// 			if (isNetworkGame()) {
// 				if (isLocalLogged) {
// 					drawSBT(strParam(s:"logged in as ", s:getLogin(player)), 160.0, base-TITLE_SPACING);
// 					drawTitleElement(isFirstHero ? "START" : "CONTINUE", 0, !state);
// 				}
// 				else {
// 					drawTitleElement("LOGIN", 0, !state);
// 					if ( !(Timer()&0x1F) )
// 						loginPoll(player);

// 				}
// 			}

// 			drawTitleElement("QUICK PLAY", 0+isNetworkGame(), state==1);
// 			drawTitleElement("OPTIONS", 1+isNetworkGame(), state==2);
// 			drawTitleElement("BACK TO GAME", 2+isNetworkGame(), state==3);

// 			// --------- logic ---------- //
			
// 			if (!state && !isNetworkGame()) {
// 				state=1;
// 			}
// 			if (isPressed(MENHUD_NO))
// 				menuStatus = -1;
// 			else if (isPressed(MENHUD_YES))
// 				switch(state) {
// 					// Slot A/B (online)
// 					case 0:
// 						if (!isLocalLogged) consolecommand("toggleconsole");
// 						else {
// 							if (isFirstHero) 
// 								menuStatus = (1<<8) | START_SCREEN_CREATE_HERO;
// 							else 
// 								menuStatus = (1<<8) | START_SCREEN_DATA;
// 						}
// 					break;

// 					// Quick play
// 					case 1:						
// 						if ((getPlayerHeroId(player,-1)==-1)) 
// 							menuStatus = (0<<8) | START_SCREEN_CREATE_HERO;
// 						else menuStatus = START_SCREEN_DATA;						
// 					break;

// 					case 2: menuStatus = START_SCREEN_OPTIONS; break;
// 					case 3: menuStatus = -1; break;
// 				}
// 			else if (isPressed(MENHUD_UP) && (state > !isNetworkGame()))
// 				state--;
// 			else if (isPressed(MENHUD_DOWN) && (state<3))
// 				state++;
// 		break;
		
// 		// case START_SCREEN_OPTIONS:

// 		// 	if (isNetworkGame())
// 		// 		drawTitleElement(strParam(s:"AUTO LOGIN is ", s:(GetCvar(CVAR_AUTOLOGIN) ? "\cdon" : "\off")), 0, !state);

// 		// 	drawTitleElement("KEY BINDS", isNetworkGame(), state==1);
// 		// 	drawTitleElement("BACK", 1, state==2);
			
// 		// 	// --------- logic ---------- //
			
// 		// 	if (!state && !isNetworkGame()) {
// 		// 		state=1;
// 		// 	}
// 		// 	if (isPressed(MENHUD_NO))
// 		// 		menuStatus = START_SCREEN_TITLE;
// 		// 	else if (isPressed(MENHUD_YES))
// 		// 		switch(state) {
// 		// 			case 0: consolecommand(strParam(s:CVAR_AUTOLOGIN, s:" ", d:!GetCvar(CVAR_AUTOLOGIN))); break;
// 		// 			case 1: log(s:"bounder"); break;
// 		// 			case 2: menuStatus = START_SCREEN_TITLE; break;
// 		// 		}
// 		// 	else if (isPressed(MENHUD_UP) && (state > !isNetworkGame()))
// 		// 		state--;
// 		// 	else if (isPressed(MENHUD_DOWN) && state<2) 
// 		// 		state++;
// 		// break;

// 		// // FFFF FF FF = confirmScreen menuIndex heroID
// 		// case START_SCREEN_CREATE_HERO:
// 		// 	index = state&0xFF;
// 		// 	drawSBT(getHeroName(index), 160.0, base);
// 		// 	drawSBT("BACK", 160.0, back);
			
// 		// 	bool confirm = state>>16;
// 		// 	if (confirm) {
// 		// 		drawSBT("Start adventure with this character?", 160.0, 110.0);
// 		// 		drawSBT("Confirm", 160.0, 110.0+TITLE_SPACING);
// 		// 		drawSBT("Back", 160.0, 110.0+TITLE_SPACING*2);
// 		// 	}
			
// 		// 	// --------- logic ---------- //
// 		// 	int heroN = GetCvar(CVAR_HERO_SIZE);

// 		// 	if (isPressed(MENHUD_NO)) {
// 		// 		if (confirm) state&=0xFFFF;
// 		// 		else menuStatus = START_SCREEN_TITLE;
// 		// 	}
// 		// 	else if (isPressed(MENHUD_YES)) {
// 		// 		if (confirm) {
// 		// 			// Confirm creation
// 		// 			if (!(confirm-1)) {
// 		// 				LocalAmbientSound("misc/secret", 127);
// 		// 				// do a "please wait.. lock here
// 		// 				ACS_NamedExecuteWithResult("8C CS", CS_PUKE, PUKE_HERO_CREATE, index, (menu>>8)-1);
// 		// 				menuStatus = (menu&0xFF00) | START_SCREEN_DATA;
// 		// 			}
// 		// 			// Cancel creation
// 		// 			else 
// 		// 				state&=0xFFFF;
// 		// 		}
// 		// 		else {
// 		// 			switch(getBit(state,8)) {
// 		// 				case 0: state |= 0x10000; break;
// 		// 				case 1: menuStatus = START_SCREEN_TITLE; break;
// 		// 			}
// 		// 		}
// 		// 	}
// 		// 	else if (isPressed(MENHUD_LEFT) && !(state>>8))
// 		// 		state = (state&0xFFFFFF00) | ((state+heroN-1) % heroN);
			
// 		// 	else if (isPressed(MENHUD_RIGHT) && !(state>>8))
// 		// 		state = (state&0xFFFFFF00) | ((state+1) % heroN);

// 		// 	else if (isPressed(MENHUD_UP)) {
// 		// 		if (confirm) {
// 		// 			if (confirm>>1) state -= 0x10000;
// 		// 		}
// 		// 		else if (getBit(state,8))
// 		// 			state = resetBit(state,8);
// 		// 	}
			
// 		// 	else if (isPressed(MENHUD_DOWN)) {
// 		// 		if (confirm) {
// 		// 			if (!(confirm>>1)) state += 0x10000;
// 		// 		}
// 		// 		else if (!getBit(state,8))
// 		// 			state = setBit(state,8);
// 		// 	}			
// 		// break;

// 		// case START_SCREEN_DATA:
// 		// 	index = state&0xFF;
// 		// 	bool isQuickPlay = !(menu>>8);
// 		// 	confirm = (state>>8)&0xFF;
// 		// 	int erase = state>>16;
// 		// 	int slots[MAX_SLOTS];
// 		// 	bool isFreeSlot = false;
// 		// 	if (isQuickPlay) {
// 		// 		slots[0] = getPlayerHeroId(player,-1);
// 		// 		drawSBT("QUICK PLAY", 160.0, base);
// 		// 		drawSBT(strParam(s:"DEFAULT : ", s:getHeroName(slots[0])), 160.0, base);
// 		// 	}
// 		// 	else {
// 		// 		drawSBT("DATA SAVES", 160.0, base);
// 		// 		for (int i = 0; i < MAX_SLOTS; i++) {
// 		// 			slots[i] = getPlayerHeroId(player,i);
// 		// 			drawSBT(strParam(s:"SLOT ", d:i, s:" : ",
// 		// 				s:(slots[i] != -1 ? getHeroName(slots[i]) : "---")),
// 		// 				160.0, base);
// 		// 		}
// 		// 	}
// 		// 	drawTitleElement("BACK", 4, !(index < (isQuickPlay ? 1 : MAX_SLOTS)));
			
// 		// 	// --------- logic ---------- //

// 		// 	if (!isQuickPlay) {
// 		// 		isFreeSlot = (getPlayerHeroId(player,index) == -1) && (index < MAX_SLOTS);
// 		// 	}
			
// 		// 	if (erase) {
// 		// 		drawSBT("Do you really want to reset data?", 160.0, 130.0);
				
// 		// 		drawTitleElement("NO", 4, !(erase>>1));
// 		// 		drawTitleElement("YES", 5, erase>>1);
// 		// 	}
// 		// 	else if (confirm) {
// 		// 		drawSBT(strParam(s:">> picked slot ", d:index, s:" <<"), 160.0, 110.0);
				
// 		// 		if (isFreeSlot) {
// 		// 			drawSBT("Create hero", 160.0, 110.0);
// 		// 			drawSBT("Back-slot", 160.0, 110.0);
// 		// 		}
// 		// 		else {
// 		// 			drawTitleElement("Start game", 2, !(confirm>>1));
// 		// 			drawTitleElement("Back", 3, !(confirm&0x1));
// 		// 			drawTitleElement("Erase data", 4, confirm&0x1);
// 		// 		}
// 		// 	}
// 		// 	// --------- logic ---------- //
			
// 		// 	if (isPressed(MENHUD_NO)) {
// 		// 		if (erase) 
// 		// 			state &= 0xFFFF;
// 		// 		else if (confirm)
// 		// 			state &= 0xFF;
// 		// 		else 
// 		// 			menuStatus = START_SCREEN_TITLE;
// 		// 	}
//  		// 	else if (isPressed(MENHUD_YES)) {
// 		// 		if (erase) {
// 		// 			if (!(erase>>1)) state &= 0xFFFF;
// 		// 			else {
// 		// 				LocalAmbientSound("misc/brgstaff", 127);
// 		// 				ACS_NamedExecuteWithResult("8C CS", CS_PUKE, PUKE_HERO_DELETE, (isQuickPlay ? -1 : index));
// 		// 				// migrate slot B to A !!
// 		// 				menuStatus = START_SCREEN_TITLE;	
// 		// 			}
// 		// 		}
				
// 		// 		else if (confirm) {
// 		// 			if (!(confirm>>1)) {
// 		// 				// character creation screen
// 		// 				if (isFreeSlot) {
// 		// 					menuStatus = ((index+1)<<8) | START_SCREEN_CREATE_HERO;
// 		// 				}
// 		// 				// start /join game
// 		// 				else {
// 		// 					LocalAmbientSound("misc/kingblast", 127);
// 		// 					log(s:"start!!");
// 		// 					menuStatus = START_SCREEN_ENTER_GAME;
// 		// 					ACS_NamedExecuteWithResult("8C CS", CS_PUKE, PUKE_SLOT_SELECT, (isQuickPlay ? -1 : index));
// 		// 				}
// 		// 			}
// 		// 			// back
// 		// 			else if (!(confirm&0x1)) 
// 		// 				state &= 0xFF;

// 		// 			// erase data
// 		// 			else
// 		// 				state |= 0x10000;
// 		// 		}
// 		// 		else {
// 		// 			if (index < (isQuickPlay ? 1 : MAX_SLOTS))
// 		// 				state |= (1<<8);
// 		// 			else
// 		// 				menuStatus = START_SCREEN_TITLE;
// 		// 		}

// 		// 	}
// 		// 	else if (isPressed(MENHUD_UP)) {
// 		// 		if (erase) {
// 		// 			if (erase>>1)
// 		// 				state -= 0x10000;
// 		// 		}
// 		// 		else if (confirm) {
// 		// 			if (confirm>1)
// 		// 				state -= 0x100;
// 		// 		}
// 		// 		else if (index) 
// 		// 			state--;
// 		// 	}
// 		// 	else if (isPressed(MENHUD_DOWN)) {
// 		// 		if (erase) {
// 		// 			if (!(erase>>1))
// 		// 				state += 0x10000;
// 		// 		}
// 		// 		else if (confirm) {
// 		// 			if (confirm<(3-isFreeSlot))
// 		// 				state += 0x100;
// 		// 		}
// 		// 		else if (index < (HERO_SLOTS-isQuickPlay))
// 		// 			state++;
// 		// 	}
// 		// break;

// 	}
// 	//if (!(timer()%2)) log(s:"menu status/slot ", d:(menu>>8)-1, s: " --- " , s:"erase? ", d:erase, s:" confirming?  ", d:confirm, s:" menu index ", d:(state&0xFF));
// 	return state;
// }

#DEFINE PUKE_HERO_CREATE 0
#DEFINE PUKE_HERO_DELETE 1
#DEFINE PUKE_LOGIN_REFRESH 2
#DEFINE PUKE_SLOT_SELECT 3

    #DEFINE PUKE_TIMED_OUT 0
    #DEFINE PUKE_OK 1
    #DEFINE PUKE_ERROR 2
    #DEFINE PUKE_SKIPPED 3

script "8C Puke" (int type, int arg1, int arg2, int arg3) NET {
	clearInv("8C Puke Response");
	if (CheckInventory("8C Puke Request")) {
		pukeReply(PUKE_SKIPPED);
		terminate;
	}
	GiveInventory("8C Puke Request", 1);
    int player = PlayerNumber();
	switch(type) {
        
        /*
        @arg1 slot
        @arg2 hero index
        */
		case PUKE_HERO_CREATE:
            Log(s:"hero create player ", d:player, s:" slot ", d:arg1, s:" hero index ", d:arg2);
            if ((arg2<0) || (arg2>=getHeroSize())) {
                log(s:"// hero index out of bounds");
				pukeReply(PUKE_ERROR); terminate; 
            }
            if ((arg1 < -1) || (arg1 >= MAX_SLOTS)) {
                log(s:"// slot out of bounds");
                pukeReply(PUKE_ERROR); terminate; 
            }
            if (getPlayerHero(player,arg1) != -1) {
                log(s:"// already have a hero on this slot");
                pukeReply(PUKE_ERROR); terminate;  
            }
            createHero(player,arg1,getHero(arg2));
            pukeReply(PUKE_OK);
		break;
        
        /*
        @arg1 slot to delete
        */
		case PUKE_HERO_DELETE:
            Log(s:"hero delete player ", d:player, s:" slot ", d:arg1);
			if (!PlayerIsSpectator(player)) {
                log(s:"// is spect");
				pukeReply(PUKE_ERROR); terminate;
            }
            else if (getPlayerHero(player,arg1) == -1) {
                log(s:"// nothing to delete here");
                pukeReply(PUKE_ERROR); terminate; 
            }
            deleteHero(player,arg1);
                // delete slot if slot == this hero's?
            pukeReply(PUKE_OK);
		break;

        /* no args */
		case PUKE_LOGIN_REFRESH:
            if (!isNetworkGame()) {
				pukeReply(PUKE_ERROR); terminate;
            }
			else if (!PlayerIsLoggedIn(arg1)) {
				setLogin(arg1, "");
				pukeReply(PUKE_ERROR); terminate;
			}
            pukeReply(PUKE_OK);
            if (isLoggedIn(arg1))                 
                terminate; // was already logged in, nothing to update

            setLogin(arg1, GetPlayerAccountName(arg1));
            //accountLoad(arg1);
		break;

        /*
        @arg1 slot index
        */
		case PUKE_SLOT_SELECT:
			if (!PlayerIsSpectator(player)) {
				pukeReply(PUKE_ERROR); terminate;
			}
			else if ((arg1 < -1) || (arg1 >= MAX_SLOTS)) {
				pukeReply(PUKE_ERROR); terminate; // slot index out of bounds
			}
			if (getPlayerHero(player,arg1) == -1) {
				pukeReply(PUKE_ERROR); terminate; // this is an empty slot
			}
			setSlot(player,arg1);
			pukeReply(PUKE_OK);
		break;
	}
}

#DEFINE DB_CREATE_HERO 0
#DEFINE DB_DELETE_HERO 1
function void dbOperation(int player, int type, int arg0, int arg1) {
    if (!PlayerIsLoggedIn(player))
        return;
    str login = GetPlayerAccountName(player);
	BeginDBTransaction();
    Log(s:">>> \ckDB transaction ", d:type, s:" for ", s:login, s:" (", d:player, s:") [", d:arg0, s:", ", d:arg1, s:"]");
    switch(type) {

        /*
        @arg0 slot
        @arg1 heroId
        */
        case DB_CREATE_HERO:
            SetDBEntry(login, strParam(s:DB_FIELD_HERO_ID, d:arg0), arg1+1);
            SetDBEntry(login, strParam(s:DB_FIELD_WEAPON, d:arg0), 0);
            SetDBEntry(login, strParam(s:DB_FIELD_EXP, d:arg0), 0);
        break;

        /*
        @arg0 slot
        */
        case DB_DELETE_HERO:
            SetDBEntry(login, strParam(s:DB_FIELD_HERO_ID, d:arg0), 0);
        break;
    }

    EndDBTransaction();
}


function void createHero(int player, int slot, int heroId) {
    setPlayerHero(player, slot, heroId);
    setPlayerWeapons(player, slot, 0);
	setExp(player, slot, 0);
    if (slot >= 0)
        dbOperation(player, DB_CREATE_HERO, slot, heroId);
}

function void deleteHero(int player, int slot) {
    setPlayerHero(player, slot, -1);
    if (slot >= 0)
        dbOperation(player, DB_DELETE_HERO, slot, 0);
}

function void pukeReply(int responseCode) {
	GiveInventory("8C Puke Response", responseCode);
}
    
function void loginPoll(int player) {
	if (!isLoggedIn(player)) {
		if (GetCvar(CVAR_AUTOLOGIN)) 
            consolecommand("login");
		ACS_NamedExecuteWithResult("8C Puke", PUKE_LOGIN_REFRESH);
	}
}
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    //////////////////////////////////////////////////////////
//                           Misc/utils            				//
	//////////////////////////////////////////////////////////

// 16 values of [2 bits]
function int get2bFlagVal(str cvar, bool incrCvar,  int var) 			{ return __getNbitFlagVal(cvar, incrCvar, var, 0xF, 4, 0xFFFF); }
function void set2bFlagVal(str cvar, bool incrCvar, int var, int val) { __setNbitFlagVal(cvar, incrCvar, var, 0xF, 4, 0xFFFF, val); }

// 8 values of [4 bits]
function int get4bFlagVal(str cvar, bool incrCvar, int var) 			{ return __getNbitFlagVal(cvar, incrCvar, var, 0x7, 3, 0xFF); }
function void set4bFlagVal(str cvar, bool incrCvar, int var, int val) 	{ __setNbitFlagVal(cvar, incrCvar, var, 0x7, 3, 0xFF, val); }

// 4 values of [8 bits]
function int get8bFlagVal(str cvar, bool incrCvar, int var) 			{ return __getNbitFlagVal(cvar, incrCvar, var, 0x3, 2, 0xF); } 
function void set8bFlagVal(str cvar, bool incrCvar, int var, int val) 	{ __setNbitFlagVal(cvar, incrCvar, var, 0x3, 2, 0xF, val); }

// 2 values of [16 bits]
function int get16bFlagVal(str cvar, bool incrCvar, int var) 				{ return __getNbitFlagVal(cvar, incrCvar, var, 0x1, 1, 0x7); }
function void set16bFlagVal(str cvar, bool incrCvar, int var, int val) 	{ __setNbitFlagVal(cvar, incrCvar, var, 0x1, 1, 0x7, val); }

function int __getNbitFlagVal(str cvar, bool incrCvar, int var, int n, int log2n, int mask) {
	n = (var&n)<<log2n;
	return ((GetCvar(incrCvar ? strParam(s:cvar, d:var>>log2n) : cvar) & (mask<<n))>>n)&mask; // "woaaah my head is spinning"
}

function void __setNbitFlagVal(str cvar, bool incrCvar, int var, int n, int log2n, int mask, int val) {
	if (incrCvar)
		cvar = strParam(s:cvar, d:var>>log2n);
	n = (var&n)<<log2n;
	SetCVar(cvar,  (GetCvar(cvar) & ~(mask<<n)) | (val<<n));		
}


function int valueOr(int object, int or) {
	if (object) return object;
	return or;
}

// the str returned by GetCvarString can cause issues when the Cvar requested doesn't exist
function str strSanitize(str string) {
	return valueOr(string,"");
}

function void clearInv(str item) { 
	TakeInventory(item,INT_MAX);
}


// general HUD draw wrapper / to call from clientside
function void draw(str data, bool isText, int x, int y, int xScreen, int yScreen, int time, int alpha) {
	SetHudSize(xScreen,yScreen,true); 	
	if (isText) {
		SetFont("CONFONT");
		int val = data;
	}
	else {
		SetFont(data); 
        val="A";
	}
	HudMessageBold(s:val;HUDMSG_PLAIN|HUDMSG_ALPHA ,Get_And_Inc_AssistDisplayID(),CR_UNTRANSLATED,x,y,time,alpha);
}

// basic version
function void drawBI(str image, int x, int y, int xScreen, int yScreen) { draw(image, false, x, y, xScreen, yScreen, 0.04, 1.0); }
function void drawBT(str text, int x, int y, int xScreen, int yScreen) { draw(text, true, x, y, xScreen, yScreen, 0.04, 1.0); }

// super basic version
function void drawSBI(str image, int x, int y) { draw(image, false, x, y, 320, 200, 0.04, 1.0); }
function void drawSBT(str text, int x, int y) { draw(text, true, x, y, 320, 200, 0.04, 1.0); }
