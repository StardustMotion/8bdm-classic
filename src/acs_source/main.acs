


	

	//////////////////////////////////////////////////////////
//                           Events             				//
	//////////////////////////////////////////////////////////
    
script "8C OPEN" OPEN {
	init();
}

bool forcePhysics, isMap8C;
function void init(void) {
	forcePhysics = GetCvar("C8_physics");
	isMap8C = !strCmp(strLeft(strParam(n:PRINTNAME_LEVEL), 3),"8C-");

    if (!getHeroSize()) {
        for (int heroId = 0, heroCount = 0; heroId < MAX_HERO; heroId++)
            if (strLen(strSanitize(__getHeroName(heroId)))) {
                setHeroFromIndex(heroCount, heroId);
                heroCount++;
            }
        SetCVar(CVAR_HERO_SIZE, heroCount);
    }

	if (isMap8C || forcePhysics) {
		for (int i = 0; i < 512; i++) 
			Sector_SetFriction(i,-96);
		DefinePowerAprop("8C Static Move Giver", "8C Static Move", APROP_Speed, 16.0, false);
		DefinePowerAprop("8C On actor gravity Giver", "8C On actor gravity", APROP_Gravity, 0.0, false);
	}

	if (isMap8C) {
		ConsoleCommand(strParam(s:"sv_maxclients ", d:min(GetCvar("sv_maxclients"), MAX_CLIENTS))); // GAMEMODE
		ConsoleCommand("mm8bdm_sv_respawnprotection 0"); // side effect / need a hook
	}
}
    
    
	//////////////////////////////////////////////////////////
//                           Core                				//
	//////////////////////////////////////////////////////////

#DEFINE NET_START_SCREEN 256
#DEFINE START_SCREEN 257
    #DEFINE START_SCREEN_TITLE 0
    #DEFINE START_SCREEN_DATA 1
    #DEFINE START_SCREEN_CREATE_HERO 2
    #DEFINE START_SCREEN_OPTIONS 3
    #DEFINE START_SCREEN_ENTER_GAME 4
    #DEFINE START_SCREEN_EXIT 5

script "8C NET CS" (int type) NET CLIENTSIDE {
	switch(type) {
		case NET_START_SCREEN:
			if (!inMenu() && PlayerIsSpectator(PlayerNumber()))
				ACS_NamedExecuteWithResult("8C CS", START_SCREEN);
		break;
	}
}

script "8C CS" (int type, int arg1, int arg2, int arg3) CLIENTSIDE {
	int localPlayer = ConsolePlayerNumber();
    switch(type) {
        case START_SCREEN:
            for (int i = 0; i < 16; i++) {
				drawBI("8CTITLTR", -32.0 + 2.0*i, 8.0, 16, 16);
				drawBI("8CTITLTR", 48.0  - 2.0*i, 9.0, 16, 16);
				delay(1);
			}
			LocalSetMusic("8CDATA");
			type = 8;
			setMenu(START_SCREEN_TITLE);
            arg3 = getMenu();
            i = 0;
            while (type < 9) {
				draw("8CTITLBL", false, 0, 0, 1, 1, 0.05, FixedDiv(type<<16,8.0));
				if (getMenu()==START_SCREEN_EXIT)
                    type++;
				else if (type)
                    type--;           
				arg2 = startScreen(arg1);    
				if (arg1 != arg2) {
					if (!(arg2>>24)) 
                        LocalAmbientSound("menu/cursor", 120); 
					arg1 = arg2;
				}
				if (arg3 != getMenu()) {
					LocalAmbientSound("misc/introstardroiddash", 120);
					arg3 = getMenu();
					if (getMenu()==START_SCREEN_EXIT) 
						continue;
					arg1 = 0;
					delay(15);
				}
                drawSBI("8CTITBG1",-160.1+((i*80)&0xFFFF0000), -96.1+((i*96)&0xFFFF0000));
				i = (i+512)&0xFFFF;
                delay(1);
            }
			for (i = 16; i >= 0; i--) {
				drawBI("8CTITLTR", -32.0 + 2.0*i, 8.0, 16, 16);
				drawBI("8CTITLTR", 48.0  - 2.0*i, 9.0, 16, 16);
				delay(1);
			}
			LocalSetMusic("*"); // if8Cmap ...
            setMenu(-1);
            // 	// if (menuStatus == START_SCREEN_ENTER_GAME) {
            // 	// 	consolecommand("menu_joingame");
            // 	// }
        break;
    }
    
}


// function int startScreen(int state) {

// 		// // FFFF FF FF = confirmScreen menuIndex heroID


// 		// case START_SCREEN_DATA:
// 		// 	index = state&0xFF;
// 		// 	bool isQuickPlay = !(menu>>8);
// 		// 	confirm = (state>>8)&0xFF;
// 		// 	int erase = state>>16;
// 		// 	int slots[MAX_SLOTS];
// 		// 	bool isFreeSlot = false;
// 		// 	if (isQuickPlay) {
// 		// 		slots[0] = getPlayerHeroId(player,-1);
// 		// 		drawSBT("QUICK PLAY", 160.0, base);
// 		// 		drawSBT(strParam(s:"DEFAULT : ", s:getHeroName(slots[0])), 160.0, base);
// 		// 	}
// 		// 	else {
// 		// 		drawSBT("DATA SAVES", 160.0, base);
// 		// 		for (int i = 0; i < MAX_SLOTS; i++) {
// 		// 			slots[i] = getPlayerHeroId(player,i);
// 		// 			drawSBT(strParam(s:"SLOT ", d:i, s:" : ",
// 		// 				s:(slots[i] != -1 ? getHeroName(slots[i]) : "---")),
// 		// 				160.0, base);
// 		// 		}
// 		// 	}
// 		// 	drawTitleElement("BACK", 4, !(index < (isQuickPlay ? 1 : MAX_SLOTS)));
			
// 		// 	// --------- logic ---------- //

// 		// 	if (!isQuickPlay) {
// 		// 		isFreeSlot = (getPlayerHeroId(player,index) == -1) && (index < MAX_SLOTS);
// 		// 	}
			
// 		// 	if (erase) {
// 		// 		drawSBT("Do you really want to reset data?", 160.0, 130.0);
				
// 		// 		drawTitleElement("NO", 4, !(erase>>1));
// 		// 		drawTitleElement("YES", 5, erase>>1);
// 		// 	}
// 		// 	else if (confirm) {
// 		// 		drawSBT(strParam(s:">> picked slot ", d:index, s:" <<"), 160.0, 110.0);
				
// 		// 		if (isFreeSlot) {
// 		// 			drawSBT("Create hero", 160.0, 110.0);
// 		// 			drawSBT("Back-slot", 160.0, 110.0);
// 		// 		}
// 		// 		else {
// 		// 			drawTitleElement("Start game", 2, !(confirm>>1));
// 		// 			drawTitleElement("Back", 3, !(confirm&0x1));
// 		// 			drawTitleElement("Erase data", 4, confirm&0x1);
// 		// 		}
// 		// 	}
// 		// 	// --------- logic ---------- //
			
// 		// 	if (isPressed(MENHUD_NO)) {
// 		// 		if (erase) 
// 		// 			state &= 0xFFFF;
// 		// 		else if (confirm)
// 		// 			state &= 0xFF;
// 		// 		else 
// 		// 			menuStatus = START_SCREEN_TITLE;
// 		// 	}
//  		// 	else if (isPressed(MENHUD_YES)) {
// 		// 		if (erase) {
// 		// 			if (!(erase>>1)) state &= 0xFFFF;
// 		// 			else {
// 		// 				LocalAmbientSound("misc/brgstaff", 127);
// 		// 				ACS_NamedExecuteWithResult("8C CS", CS_PUKE, PUKE_HERO_DELETE, (isQuickPlay ? -1 : index));
// 		// 				// migrate slot B to A !!
// 		// 				menuStatus = START_SCREEN_TITLE;	
// 		// 			}
// 		// 		}
				
// 		// 		else if (confirm) {
// 		// 			if (!(confirm>>1)) {
// 		// 				// character creation screen
// 		// 				if (isFreeSlot) {
// 		// 					menuStatus = ((index+1)<<8) | START_SCREEN_CREATE_HERO;
// 		// 				}
// 		// 				// start /join game
// 		// 				else {
// 		// 					LocalAmbientSound("misc/kingblast", 127);
// 		// 					log(s:"start!!");
// 		// 					menuStatus = START_SCREEN_ENTER_GAME;
// 		// 					ACS_NamedExecuteWithResult("8C CS", CS_PUKE, PUKE_SLOT_SELECT, (isQuickPlay ? -1 : index));
// 		// 				}
// 		// 			}
// 		// 			// back
// 		// 			else if (!(confirm&0x1)) 
// 		// 				state &= 0xFF;

// 		// 			// erase data
// 		// 			else
// 		// 				state |= 0x10000;
// 		// 		}
// 		// 		else {
// 		// 			if (index < (isQuickPlay ? 1 : MAX_SLOTS))
// 		// 				state |= (1<<8);
// 		// 			else
// 		// 				menuStatus = START_SCREEN_TITLE;
// 		// 		}

// 		// 	}
// 		// 	else if (isPressed(MENHUD_UP)) {
// 		// 		if (erase) {
// 		// 			if (erase>>1)
// 		// 				state -= 0x10000;
// 		// 		}
// 		// 		else if (confirm) {
// 		// 			if (confirm>1)
// 		// 				state -= 0x100;
// 		// 		}
// 		// 		else if (index) 
// 		// 			state--;
// 		// 	}
// 		// 	else if (isPressed(MENHUD_DOWN)) {
// 		// 		if (erase) {
// 		// 			if (!(erase>>1))
// 		// 				state += 0x10000;
// 		// 		}
// 		// 		else if (confirm) {
// 		// 			if (confirm<(3-isFreeSlot))
// 		// 				state += 0x100;
// 		// 		}
// 		// 		else if (index < (HERO_SLOTS-isQuickPlay))
// 		// 			state++;
// 		// 	}
// 		// break;

// 	}
// 	//if (!(timer()%2)) log(s:"menu status/slot ", d:(menu>>8)-1, s: " --- " , s:"erase? ", d:erase, s:" confirming?  ", d:confirm, s:" menu index ", d:(state&0xFF));
// 	return state;
// }

// wtf is this design pattern ? o wo ' -' ' -'XD? ?
// render/process logic, and return the new logic state
function int startScreen(int state) {
    switch(getMenu()&0xFF) {
        case START_SCREEN_TITLE:
            int player = ConsolePlayerNumber();
            bool isFirstHero = isSlotEmpty(player,0) && isSlotEmpty(player,1);
            bool isOnline = isNetworkGame(), logged = isLoggedIn(player);

			// --------- render ---------- //	
            if (isOnline) {
                if (logged) {
                    drawTitle(strParam(s:"logged in as ", s:getLogin(player)), -1, false);
                    drawTitle(isFirstHero ? "START" : "CONTINUE", 0, !state);
                }
                else {
                    drawTitle("LOGIN", 0, !state);
					if (!(Timer()&0x1F)) 
                        loginPoll(player);
                }
            }
            drawTitle("QUICK PLAY", 0+isOnline, state==1);
            drawTitle("OPTIONS", 1+isOnline, state==2);
            drawTitle("BACK TO GAME", 2+isOnline, state==3);


			// --------- logic ---------- //			
			if (!state && !isOnline) {
				state=1;
			}
			if (isPressed(MENU_NO)) 
                setMenu(START_SCREEN_EXIT);
			else if (isPressed(MENU_UP) && (state > !isOnline))
				state--;
			else if (isPressed(MENU_DOWN) && (state < 3))
				state++;
            else if (isPressed(MENU_YES))
                switch(state) {
                    case 0:
                        if (!logged) // "LOGIN"
                            consolecommand("toggleconsole");
                        else {                            
							if (isFirstHero)             // "START"
								setMenu((1<<8) | START_SCREEN_CREATE_HERO);                          
							else                         // "CONTINUE"
								setMenu((1<<8) | START_SCREEN_DATA);      
						}
                    break;

                    case 1: // "QUICK PLAY"
                        setMenu(isSlotEmpty(player,-1) ?
                                    (0<<8) | START_SCREEN_CREATE_HERO :
                                    START_SCREEN_DATA);
                    break;
                    
                    case 2: setMenu(START_SCREEN_OPTIONS);  break;
                    case 3: setMenu(START_SCREEN_EXIT);     break;
                }

        break;

        case START_SCREEN_OPTIONS:
            isOnline = isNetworkGame();

            // PICKUP STYLE MM7 MM8 ETC

			// --------- render ---------- //
            if (isOnline)
                drawTitle(strParam(s:"AUTO LOGIN is ", s:(GetCvar(CVAR_AUTOLOGIN) ? "\cdon" : "\cgff")), 0, !state);
            drawTitle("KEY BINDS", 0+isOnline, state==1);
			drawTitle("BACK", 1+isOnline, state==2);

			// --------- logic ---------- //	
			if (!state && !isOnline) {
				state=1;
			}
			if (isPressed(MENU_NO))
				setMenu(START_SCREEN_TITLE);
			else if (isPressed(MENU_UP) && (state > !isOnline))
				state--;
			else if (isPressed(MENU_DOWN) && (state < 2)) 
				state++;
			else if (isPressed(MENU_YES))
				switch(state) {
					case 0: consolecommand(strParam(s:CVAR_AUTOLOGIN, s:" ", d:!GetCvar(CVAR_AUTOLOGIN))); break;
					case 1: log(s:"bounder"); break;
					case 2: setMenu(START_SCREEN_TITLE); break;
				}
        break;

        case START_SCREEN_CREATE_HERO:
            int n = getHeroSize();
            int confirmStatus = (state>>16)&0x3;
            int delta = (state>>24);
            player = state&0xFF;

			// --------- render ---------- //


            log(s:"delta ", d:delta, s:" state ", d:state&0xFF);
            if (delta) {
                drawSBI("8CTITLW1", 160.0, 0.1);
                drawBI(getHeroMugshot((player+n-1)%n), 260.0, 8.1, 640, 400);
                drawBI(getHeroMugshot(player), 295.0, 41.1, 640, 400);
                drawBI(getHeroMugshot((player+1)%n), 343.0, 41.1, 640, 400);
                drawBI(getHeroMugshot((player+2)%n), 376.0, 8.1, 640, 400);
            }
            else {
                drawSBI("8CTITLW0", 160.0, 0.1);
                drawBI(getHeroMugshot((player+n-2)%n), 256.0, -18.1, 640, 400);
                drawBI(getHeroMugshot((player+n-1)%n), 274.0, 32.1, 640, 400);
                drawBI(getHeroMugshot(player), 320.0, 48.1, 640, 400);
                drawBI(getHeroMugshot((player+1)%n), 366.0, 32.1, 640, 400);
                drawBI(getHeroMugshot((player+2)%n), 384.0, -18.1, 640, 400);
            }
            
            
            
            /*
            */


            drawBI(getHeroIdle(player), 50.0, 110.0, 200, 125);
            drawSBT(getHeroName(player), 160.0, 40.0);
            
            //drawSBT(lineBreak(getHeroText(player),16), 160.0, 120.0);

            
            drawBT(strParam(d:getHeroWeapons(player), 
                s:" * ", d:getHeroWeaponGroups(player)), 220.2, 65.0, 400, 250);
            
            drawBT(getSpSkill(player), 327.2, 112.0, 400, 250);

            drawBI("8CTITLM5", 148.0, 100.0, 288, 180);
            drawSBI("8CTITLM7", 65.0, 105.0);
            drawSBI("8CTITLME", 80.0, 50.0);

            if (confirmStatus) {
                //drawSBT("Start adventure with this character?", 160.0, 110.0);
			    drawTitle("Confirm", -2, false);
			    drawTitle("Cancel", -1, false);
            }

			//drawTitle("Back", 0, (state>>8));


			// --------- logic ---------- //
            if (delta) {                
                if ((delta&0xF)==5) {
                    if (delta>>4) // <=
                        state &= 0xFFFFFF;
                    else // =>
                        state = (state&0xFFFF00) | ((player+1) % n);
                }
                else 
                    state += 0x01000000;
                break;
            }
			if (isPressed(MENU_NO)) {
				if (confirmStatus) state &= 0xFFFF;
				else setMenu(START_SCREEN_TITLE);
			}
            else if (isPressed(MENU_LEFT) && !(state>>8)) {
                state = 0x11000000 | (state&0x00FFFF00) | ((player+n-1) % n);
            }
            else if (isPressed(MENU_RIGHT) && !(state>>8)) {
                state |= 0x01000000;
            }
            else if (isPressed(MENU_UP)) {
                if (confirmStatus) {
                    if (confirmStatus>>1) state -= 0x10000;
                }
                else if (getBit(state,8))
                    state = bitOff(state,8);
            }
            else if (isPressed(MENU_DOWN)) {
                if (confirmStatus) {
                    if (!(confirmStatus>>1)) state += 0x10000;
                }
                else if (!getBit(state,8))
                    state = bitOn(state,8);
            }
            else if (isPressed(MENU_YES)) {
                if (confirmStatus) {
                    if (!(confirmStatus-1)) {
						LocalAmbientSound("misc/secret", 127);
						// do a "please wait.. lock here
						//ACS_NamedExecuteWithResult("8C CS", CS_PUKE, PUKE_HERO_CREATE, player, (menu>>8)-1);
						//setMenu((getMenu()&0xFF00) | START_SCREEN_DATA);
						setMenu(START_SCREEN_TITLE);
                    }
                    else // Cancel creation
                        state &= 0xFFFF;
                }
                else {
					switch(getBit(state,8)) {
						case 0: state |= 0x10000; break;
						case 1: setMenu(START_SCREEN_TITLE); break;
					}
                }
            }
            
        break;

			
    }
    if (!(timer()&0x1F) )
        log(s:"confirm ", d:confirmStatus,  s:" player ", d:player);
    return state;
}

#DEFINE TITLE_SPACING 42.0
function void drawTitle(str label, int offset, bool isSelected) {	
	drawBT(strParam(s:"\cc", s:label), 200.0, 40.0+offset*TITLE_SPACING, 400, 250);
	drawBI(strParam(s:"8CTITLM", d:isSelected), 140.0, 24.0+offset*TITLE_SPACING, 400, 250);
}

#DEFINE PUKE_HERO_CREATE 0
#DEFINE PUKE_HERO_DELETE 1
#DEFINE PUKE_LOGIN_REFRESH 2
#DEFINE PUKE_SLOT_SELECT 3

    #DEFINE PUKE_TIMED_OUT 0
    #DEFINE PUKE_OK 1
    #DEFINE PUKE_ERROR 2
    #DEFINE PUKE_SKIPPED 3

script "8C Puke" (int type, int arg1, int arg2, int arg3) NET {
	clearInv("8C Puke Response");
	if (CheckInventory("8C Puke Request")) {
		pukeReply(PUKE_SKIPPED);
		terminate;
	}
	GiveInventory("8C Puke Request", 1);
    int player = PlayerNumber();
	switch(type) {
        
        /*
        @arg1 slot
        @arg2 hero index
        */
		case PUKE_HERO_CREATE:
            Log(s:"hero create player ", d:player, s:" slot ", d:arg1, s:" hero index ", d:arg2);
            if ((arg2<0) || (arg2>=getHeroSize())) {
                log(s:"// hero index out of bounds");
				pukeReply(PUKE_ERROR); terminate; 
            }
            if ((arg1 < -1) || (arg1 >= MAX_SLOTS)) {
                log(s:"// slot out of bounds");
                pukeReply(PUKE_ERROR); terminate; 
            }
            if (!isSlotEmpty(player,arg1)) {
                log(s:"// already have a hero on this slot");
                pukeReply(PUKE_ERROR); terminate;  
            }
            createHero(player,arg1,getHeroFromIndex(arg2));
            pukeReply(PUKE_OK);
		break;
        
        /*
        @arg1 slot to delete
        */
		case PUKE_HERO_DELETE:
            Log(s:"hero delete player ", d:player, s:" slot ", d:arg1);
			if (!PlayerIsSpectator(player)) {
                log(s:"// is spect");
				pukeReply(PUKE_ERROR); terminate;
            }
            else if (isSlotEmpty(player,arg1)) {
                log(s:"// nothing to delete here");
                pukeReply(PUKE_ERROR); terminate; 
            }
            deleteHero(player,arg1);
                // delete slot if slot == this hero's?
            pukeReply(PUKE_OK);
		break;

        /* no args */
		case PUKE_LOGIN_REFRESH:
            if (!isNetworkGame()) {
				pukeReply(PUKE_ERROR); terminate;
            }
			else if (!PlayerIsLoggedIn(arg1)) {
				setLogin(arg1, "");
				pukeReply(PUKE_ERROR); terminate;
			}
            pukeReply(PUKE_OK);
            if (isLoggedIn(arg1))                 
                terminate; // was already logged in, nothing to update

            setLogin(arg1, GetPlayerAccountName(arg1));
            //accountLoad(arg1);
		break;

        /*
        @arg1 slot index
        */
		case PUKE_SLOT_SELECT:
			if (!PlayerIsSpectator(player)) {
				pukeReply(PUKE_ERROR); terminate;
			}
			else if ((arg1 < -1) || (arg1 >= MAX_SLOTS)) {
				pukeReply(PUKE_ERROR); terminate; // slot index out of bounds
			}
			if (isSlotEmpty(player,arg1)) {
				pukeReply(PUKE_ERROR); terminate; // this is an empty slot
			}
			setSlot(player,arg1);
			pukeReply(PUKE_OK);
		break;
	}
}

#DEFINE DB_CREATE_HERO 0
#DEFINE DB_DELETE_HERO 1
function void dbOperation(int player, int type, int arg0, int arg1) {
    if (!PlayerIsLoggedIn(player))
        return;
    str login = GetPlayerAccountName(player);
	BeginDBTransaction();
    Log(s:">>> \ckDB transaction ", d:type, s:" for ", s:login, s:" (", d:player, s:") [", d:arg0, s:", ", d:arg1, s:"]");
    switch(type) {

        /*
        @arg0 slot
        @arg1 heroId
        */
        case DB_CREATE_HERO:
            SetDBEntry(login, strParam(s:DB_FIELD_HERO_ID, d:arg0), arg1+1);
            SetDBEntry(login, strParam(s:DB_FIELD_WEAPON, d:arg0), 0);
            SetDBEntry(login, strParam(s:DB_FIELD_EXP, d:arg0), 0);
        break;

        /*
        @arg0 slot
        */
        case DB_DELETE_HERO:
            SetDBEntry(login, strParam(s:DB_FIELD_HERO_ID, d:arg0), 0);
        break;
    }

    EndDBTransaction();
}


function void createHero(int player, int slot, int heroId) {
    setPlayerHero(player, slot, heroId);
    setWepUnlocked(player, slot, 0);
	setExp(player, slot, 0);
    if (slot >= 0)
        dbOperation(player, DB_CREATE_HERO, slot, heroId);
}

function void deleteHero(int player, int slot) {
    setPlayerHero(player, slot, -1);
    if (slot >= 0)
        dbOperation(player, DB_DELETE_HERO, slot, 0);
}

function void pukeReply(int responseCode) {
	GiveInventory("8C Puke Response", responseCode);
}
    
function void loginPoll(int player) {
	if (!isLoggedIn(player)) {
		if (GetCvar(CVAR_AUTOLOGIN)) 
            consolecommand("login");
		ACS_NamedExecuteWithResult("8C Puke", PUKE_LOGIN_REFRESH);
	}
}
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    //////////////////////////////////////////////////////////
//                           Misc/utils            				//
	//////////////////////////////////////////////////////////
    
function int getBit(int x, int b) { return (x & (1 << b))>>b; }
function int bitOn(int x, int b) { return x | (1 << b); }
function int bitOff(int x, int b) { return x & ~(1 << b); }

// 16 values of [2 bits]
function int get2bFlagVal(str cvar, bool incrCvar,  int var) 			{ return __getNbitFlagVal(cvar, incrCvar, var, 0xF, 4, 0xFFFF); }
function void set2bFlagVal(str cvar, bool incrCvar, int var, int val) { __setNbitFlagVal(cvar, incrCvar, var, 0xF, 4, 0xFFFF, val); }

// 8 values of [4 bits]
function int get4bFlagVal(str cvar, bool incrCvar, int var) 			{ return __getNbitFlagVal(cvar, incrCvar, var, 0x7, 3, 0xFF); }
function void set4bFlagVal(str cvar, bool incrCvar, int var, int val) 	{ __setNbitFlagVal(cvar, incrCvar, var, 0x7, 3, 0xFF, val); }

// 4 values of [8 bits]
function int get8bFlagVal(str cvar, bool incrCvar, int var) 			{ return __getNbitFlagVal(cvar, incrCvar, var, 0x3, 2, 0xF); } 
function void set8bFlagVal(str cvar, bool incrCvar, int var, int val) 	{ __setNbitFlagVal(cvar, incrCvar, var, 0x3, 2, 0xF, val); }

// 2 values of [16 bits]
function int get16bFlagVal(str cvar, bool incrCvar, int var) 				{ return __getNbitFlagVal(cvar, incrCvar, var, 0x1, 1, 0x7); }
function void set16bFlagVal(str cvar, bool incrCvar, int var, int val) 	{ __setNbitFlagVal(cvar, incrCvar, var, 0x1, 1, 0x7, val); }

function int __getNbitFlagVal(str cvar, bool incrCvar, int var, int n, int log2n, int mask) {
	n = (var&n)<<log2n;
	return ((GetCvar(incrCvar ? strParam(s:cvar, d:var>>log2n) : cvar) & (mask<<n))>>n)&mask; // "woaaah my head is spinning"
}

function void __setNbitFlagVal(str cvar, bool incrCvar, int var, int n, int log2n, int mask, int val) {
	if (incrCvar)
		cvar = strParam(s:cvar, d:var>>log2n);
	n = (var&n)<<log2n;
	SetCVar(cvar,  (GetCvar(cvar) & ~(mask<<n)) | (val<<n));		
}

function int valueOr(int object, int or) {
	if (object) return object;
	return or;
}

// the str returned by GetCvarString can cause issues when the Cvar requested doesn't exist
function str strSanitize(str string) {
	return valueOr(string,"");
}

function void clearInv(str item) { 
	TakeInventory(item,INT_MAX);
}

// general HUD draw wrapper / to call from clientside
function void draw(str data, bool isText, int x, int y, int xScreen, int yScreen, int time, int alpha) {
	SetHudSize(xScreen,yScreen,true); 	
	if (isText) {
		SetFont("CONFONT");
		int val = data;
	}
	else {
		SetFont(data); 
        val="A";
	}
	HudMessageBold(s:val;HUDMSG_PLAIN|HUDMSG_ALPHA ,Get_And_Inc_AssistDisplayID(),CR_UNTRANSLATED,x,y,time,alpha);
}

// basic version
function void drawBI(str image, int x, int y, int xScreen, int yScreen) { draw(image, false, x, y, xScreen, yScreen, 0.04, 1.0); }
function void drawBT(str text, int x, int y, int xScreen, int yScreen) { draw(text, true, x, y, xScreen, yScreen, 0.04, 1.0); }

// super basic version
function void drawSBI(str image, int x, int y) { draw(image, false, x, y, 320, 200, 0.04, 1.0); }
function void drawSBT(str text, int x, int y) { draw(text, true, x, y, 320, 200, 0.04, 1.0); }

function bool isPressed(int key) {
	return !(GetPlayerInput(-1, INPUT_OLDBUTTONS) & key) && (GetPlayerInput(-1, INPUT_BUTTONS) & key);
}

function str lineBreak(str string, int every) {
    str s = "";
    int length = strLen(string);
    while (length>0) {
        s = strParam(s:s, s:strLeft(string, every), s:"\n");
        length-=every;
        string = strRight(string, length);
    }
    return s;
}