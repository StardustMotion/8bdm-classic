

#DEFINE FLOOR_FRICTION -96

script "8C OPEN" OPEN {
	DefinePowerAprop("8C Static Move Giver", "8C Static Move", APROP_Speed, 16.0, false);
	DefinePowerAprop("8C On actor gravity Giver", "8C On actor gravity", APROP_Gravity, 0.0, false);
	
	for (int i = 0; i < 256; i++) {
		Sector_SetFriction(i,FLOOR_FRICTION);
	}
}

script "8C ENTER" ENTER {
	ACS_NamedExecuteWithResult("8C", PLAYER_MORPH);
}


function int roundf(int f) { 
	return (f+0.5)&0xFFFF0000; 
}


script "8C" (int type, int arg1, int arg2, int arg3) {
	switch(type) {
		case XY_DIST:
			if (!arg1) arg1 = GetActorProperty(0, APROP_TARGETTID);
			SetResultValue(xyDistance(0,arg1));
		break;

		case Z_DIST:
			if (!arg1) arg1 = GetActorProperty(0, APROP_TARGETTID);
			SetResultValue(zDistance(0,arg1));
		break;

		// summon on spot 5 a big eye (tier 2)
		// ACS_NamedExecuteWithResult("8C", 255, pos, type, version) 
		// pukename 8c 255 0 2 0
		case MOB_SPAWN:
			if (!arg3)				int name = StrParam(s:"8C ", s:mobs[arg2]);
			else						name = StrParam(s:"8C ", s:mobs[arg2], s:" V", d:arg3+1);

			int tmp = UniqueTID();
			arg1 = SpawnSpotFacingForced(name, arg1, tmp);
			if (!arg1) {
				Log(s:"[MOB FACTORY] Can't spawn \"", s:name, s:"\", either this actor code is not defined, or the spawn spot doesn't exist");
				terminate;
			}

			int i = random(0,1);//!random(0,1024);
			if (i) 
				GiveActorInventory(tmp, "8C Shiny", 1);
			arg1 = MOB_COLOR+(arg2*MOB_COLOR_SIZE)+i+(arg3<<1);
			SetUserVariable(tmp, "user_colorId", arg1);
			Thing_SetTranslation(tmp, arg1);
			Setactorposition(tmp,GetActorX(tmp)+128.0,GetActorY(tmp),GetActorZ(tmp),false);
			Thing_ChangeTID(tmp, 0);
		break;

		case IS_GONE:
			SetResultValue(isGone(arg1));
		break;

		case COPY_VELOCITY:
			GiveInventory("8C follower",1);
			do {
				arg2 = 0;//ACS_NamedExecuteWithResult("8C", GET_VELOCITY, arg1);				
				SetActorVelocity(0, 
					((1-((arg2>>23)&0x2))*(arg2&0xFF))<<16, 
					((1-((arg2>>24)&0x2))*(arg2&0xFF00))<<8, 
					(1-((arg2>>25)&0x2))*(arg2&0xFF0000), 
				false, false);
				delay(1);
			} while (CheckInventory("8C follower"));
		break;

		case GET_VELOCITY:
			SetActivator(0, arg1);
			SetResultValue(
				(abs(GetActorVelX(0)>>16)&0xFF) |
				((abs(GetActorVelY(0)>>16)&0xFF) << 8) |
				((abs(GetActorVelZ(0)>>16)&0xFF) << 16) |
				((GetActorVelX(0)<0)<<24) |
				((GetActorVelY(0)<0)<<25) |
				((GetActorVelZ(0)<0)<<26)
			);
		break;

		// detect lateral collision with terrain/actors. Used i.e by Cutting Wheel to climb
		case CHECK_COLLISION:
			arg3 = GetActorAngle(0)+ 0.25*arg1;
			int rad = GetActorProperty(0,APROP_Radius)>>16;

			// increase this to help non axis aligned collision detection
			// but at the cost of overall worsened collision accuracy
			arg1 = (rad*5)/3;
			
			if (arg2) 	tmp = "8C Check Collision";
			else 		tmp = "8C Check Terrain";
			i = UniqueTID();

			while (true) {
				type = !Spawn(tmp,
					GetActorX(0) + (arg1 * cos(arg3)) - rad*sin(arg3),
					GetActorY(0) + (arg1 * sin(arg3)) + rad*cos(arg3),
					GetActorZ(0),
					i);
				if (type) break;
				type = !Spawn(tmp,
					GetActorX(0) + (arg1 * cos(arg3)) + rad*sin(arg3),
					GetActorY(0) + (arg1 * sin(arg3)) - rad*cos(arg3),
					GetActorZ(0)+GetActorProperty(0,APROP_Height)-12.0,
					i);
				break;
			}

			SetResultValue(type);
			//Log(s:"collide ? ", d:type);
			Thing_Remove(i);
		break;

		// core_unsolidplayer but more simple, usable for monsters
		case SOLID_TOGGLE:
			if (!arg1) {
				GiveInventory("PlayerPropertyUnsolid", 1);
				GiveInventory("PlayerPropertySolidOff",1);
			}
			else if (CheckInventory("PlayerPropertyUnsolid")) {
				TakeInventory("PlayerPropertyUnsolid", 1);				
				if (!CheckInventory("PlayerPropertyUnsolid"))
					GiveInventory("PlayerPropertySolidOn", 1);
			}
		break;

		// only used for color get now, generalize later maybe
		case GET_USERVAR:
		if (arg1) SetActivator(0,arg1);
		SetResultValue(GetUserVariable(0, "user_colorId"));
		break;

		case PLAYER_MORPH:
			delay(2);
			MorphActor(0,"8C-MEGAMAN", "",0x7FFFFFFF,MRF_FULLHEALTH|MRF_FAILNOLAUGH|MRF_NEWTIDBEHAVIOUR,"gfx","gfx");
			GiveInventory("BaseFlagPack",1);
			GiveInventory("BassBuster",1);
			GiveInventory("8C Static Move Giver", 1);
			SetAirControl(8.392333); // 5.905 for airspeed = groundspeed
			/*
			while (true) { // airFriction control }}
			Player air movement was planned to have lower friction + slower player speed,
				resulting in jumps being hard to readjust direction, but gaining more momentum/speed (like doom jumps.)
			This, as a contract to ground movement - high friction + high player speed, resulting in good dodging/position,
			but not good to cover distances.

			It was dropped because modifying player's speed based on grounded/in air (with setactorproperty or powerspeed i.e)
			couldn't use client-side prediction to make player movement online smooth.
			See https://zdoom.org/wiki/Creating_multiplayer-friendly_ZScript

			Need Player.Forward/Side move properties but for in-air specific :D

			-----------------------------------------------------------------------------------------------

				Also for some reason when an actor (the player) is standing on a solid actor (i.e yoku block),
				the aircontrol (friction) stops applying, giving player a surge of speed
				We reposition the player 1 unit above the solid actor, with no gravity, just so aircontrol applies again (code below)
				
				Limitations though : there's still 1 tic of speed surge (when landing on the actor),
				also jump reproduction not accurate ; it allows jumping on the same time t when you land on the actor
			*/
			while(!isGone(0)) {
				if ((GetActorZ(0)-GetActorFloorZ(0))>=1.0)
					if (!checkFooting(-1.0)) {
						SetActorVelocity(0,GetActorVelX(0),GetActorVelY(0),0.0,false,false);
						SetActorPosition(0,GetActorX(0),GetActorY(0),GetActorZ(0)+1.0,false);
						GiveInventory("8C On actor gravity Giver", 1);
						do {
							delay(1);
							if (GetPlayerInput(-1,INPUT_BUTTONS)&BT_JUMP) {
								SetActorVelocity(0,GetActorVelX(0),GetActorVelY(0),GetActorProperty(0,APROP_JumpZ),false,false);
								break;
							}
						}  while (!checkFooting(-2.0));
						TakeInventory("8C On actor gravity", 1);

					}
				delay(1);
			}
		break;
	}
}

function bool isGone(int ptr) {
	if (ptr) {
		SetActivator(0,ptr);
		ptr = 0;
	} 
	int flags = ClassifyActor(ptr);
	return (flags & (ACTOR_WORLD | ACTOR_DEAD)) || ((flags & ACTOR_PLAYER) && PlayerIsSpectator(PlayerNumber()));
}

function bool checkFooting(int zOffset) {
	int tid = UniqueTID();
	bool check = Spawn("8bdmFootholdCheck",GetActorX(0),GetActorY(0),GetActorZ(0)+zOffset,tid);
	Thing_Remove(tid);
	return check;
}

script "8C Event" (int type, int damage, int damageType) EVENT {
	switch(type) {
		case GAMEEVENT_ACTOR_DAMAGED:

			//if (damgetype = cuttingwheel) playsound 8CCUTWHX

			bool isVictimMob = CheckInventory("8C flags") & FLAG_MOB;

			if (CheckInventory("8C flags") & FLAG_DEFLECT) {
				PlaySound(0,"8CPAIN02",CHAN_VOICE,1.0,false);
				type = SetActivator(0, AAPTR_DAMAGE_INFLICTOR);
				SpawnForced("8C Deflect gfx", GetActorX(0), GetActorY(0), GetActorZ(0));
				if (type && !CheckFlag(0, "DONTREFLECT")) {
                	SetPointer(AAPTR_TARGET, 0, AAPTR_DAMAGE_TARGET);
					SetActorVelocity(0, -GetActorVelY(0), GetActorVelX(0), -16.0, false, false);
				}
				SetResultValue(0);
				break;
			}

			//
			if (isVictimMob) {
       			PlaySound(0,"8CPAIN00",CHAN_VOICE,1.0,false);
				
				type = GetUserVariable(0, "user_colorId");
				for (int i = 0; i < 5; i++) {
					Thing_SetTranslation(0, 68); // CLR_BOSSPAIN
					delay(1);
					Thing_SetTranslation(0, type);
					delay(1);

				}
			}
		break;
		
	}
}

// from xover weapons 2.1.0
script "EarthQuake" (int strength, int duration, int range) {
	Radius_Quake(strength, duration, 0, range/64, 0); }

// script "onche" (void) {
// 	Log(s:"pre ", s:GetActorClass(0));
// 	Log(s:"morph ", d:SetPlayerClass(0, "8C Protoman", true));
// 	Log(s:"pre ", s:GetActorClass(0));
// }

// script "tagle" (void) {
// 	Log(s:"morph ", d:MorphActor(0,"8C Protoman", "", 0xFFFFFFFF, 0, "", ""));
// }