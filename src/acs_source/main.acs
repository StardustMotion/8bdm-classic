


	

	//////////////////////////////////////////////////////////
//                           Events             				//
	//////////////////////////////////////////////////////////
    
script "8C OPEN" OPEN {
	init();
}

bool forcePhysics, isMap8C;
function void init(void) {
	forcePhysics = GetCvar("C8_physics");
	isMap8C = !strCmp(strLeft(strParam(n:PRINTNAME_LEVEL), 3),"8C-");

    if (!getHeroSize()) {
        for (int heroId = 0, heroCount = 0; heroId < MAX_HERO; heroId++)
            if (strLen(strSanitize(__getHeroName(heroId)))) {
                setHeroFromIndex(heroCount, heroId);
                heroCount++;
            }
        SetCVar(CVAR_HERO_SIZE, heroCount);
    }

	if (isMap8C || forcePhysics) {
		for (int i = 0; i < 512; i++) 
			Sector_SetFriction(i,-96);
		DefinePowerAprop("8C Static Move Giver", "8C Static Move", APROP_Speed, 16.0, false);
		DefinePowerAprop("8C On actor gravity Giver", "8C On actor gravity", APROP_Gravity, 0.0, false);
	}

	if (isMap8C) {
		ConsoleCommand(strParam(s:"sv_maxclients ", d:min(GetCvar("sv_maxclients"), MAX_CLIENTS))); // GAMEMODE
		ConsoleCommand("mm8bdm_sv_respawnprotection 0"); // side effect / need a hook
	}
}
    
    
	//////////////////////////////////////////////////////////
//                           Core                				//
	//////////////////////////////////////////////////////////


    

#DEFINE PUKE_HERO_CREATE 0
#DEFINE PUKE_HERO_DELETE 1
#DEFINE PUKE_LOGIN_REFRESH 2
#DEFINE PUKE_SLOT_SELECT 3
    #DEFINE PUKE_WAITING 0
    #DEFINE PUKE_OK 1
    #DEFINE PUKE_ERROR 2
    #DEFINE PUKE_SKIPPED 3
    #DEFINE PUKE_TIMED_OUT 4
        #DEFINE PUKE_TIMEOUT 70

script "8C Puke" (int type, int arg1, int arg2, int arg3) NET {
	clearInv("8C Puke Response");
	if (CheckInventory("8C Puke Request")) {
		pukeReply(PUKE_SKIPPED);
		terminate;
	}
	GiveInventory("8C Puke Request", 1);
    int player = PlayerNumber();
	switch(type) {
        
        /*
        @arg1 slot
        @arg2 hero index
        */
		case PUKE_HERO_CREATE:
            Log(s:"hero create player ", d:player, s:" slot ", d:arg1, s:" hero index ", d:arg2);
            if ((arg2<0) || (arg2>=getHeroSize())) {
                log(s:"// hero index out of bounds");
				pukeReply(PUKE_ERROR); terminate; 
            }
            if ((arg1 < -1) || (arg1 >= MAX_SLOTS)) {
                log(s:"// slot out of bounds");
                pukeReply(PUKE_ERROR); terminate; 
            }
            if (!isSlotEmpty(player,arg1)) {
                log(s:"// already have a hero on this slot");
                pukeReply(PUKE_ERROR); terminate;  
            }
            //createHero(player,arg1,getHeroFromIndex(arg2));
            pukeReply(PUKE_OK);
		break;
        
        /*
        @arg1 slot to delete
        */
		case PUKE_HERO_DELETE:
            Log(s:"hero delete player ", d:player, s:" slot ", d:arg1);
			if (!PlayerIsSpectator(player)) {
                log(s:"// is spect");
				pukeReply(PUKE_ERROR); terminate;
            }
            else if (isSlotEmpty(player,arg1)) {
                log(s:"// nothing to delete here");
                pukeReply(PUKE_ERROR); terminate; 
            }
            deleteHero(player,arg1);
                // delete slot if slot == this hero's?
            pukeReply(PUKE_OK);
		break;

        /* no args */
		case PUKE_LOGIN_REFRESH:
            if (!isNetworkGame()) {
				pukeReply(PUKE_ERROR); terminate;
            }
			else if (!PlayerIsLoggedIn(arg1)) {
				setLogin(arg1, "");
				pukeReply(PUKE_ERROR); terminate;
			}
            pukeReply(PUKE_OK);
            if (isLoggedIn(arg1))                 
                terminate; // was already logged in, nothing to update

            setLogin(arg1, GetPlayerAccountName(arg1));
            //accountLoad(arg1);
		break;

        /*
        @arg1 slot index
        */
		case PUKE_SLOT_SELECT:
			if (!PlayerIsSpectator(player)) {
				pukeReply(PUKE_ERROR); terminate;
			}
			else if ((arg1 < -1) || (arg1 >= MAX_SLOTS)) {
				pukeReply(PUKE_ERROR); terminate; // slot index out of bounds
			}
			if (isSlotEmpty(player,arg1)) {
				pukeReply(PUKE_ERROR); terminate; // this is an empty slot
			}
			setSlot(player,arg1);
			pukeReply(PUKE_OK);
		break;
	}
}

#DEFINE DB_CREATE_HERO 0
#DEFINE DB_DELETE_HERO 1
function void dbOperation(int player, int type, int arg0, int arg1) {
    if (!PlayerIsLoggedIn(player))
        return;
    str login = GetPlayerAccountName(player);
	BeginDBTransaction();
    Log(s:">>> \ckDB transaction ", d:type, s:" for ", s:login, s:" (", d:player, s:") [", d:arg0, s:", ", d:arg1, s:"]");
    switch(type) {

        /*
        @arg0 slot
        @arg1 heroId
        */
        case DB_CREATE_HERO:
            SetDBEntry(login, strParam(s:DB_FIELD_HERO_ID, d:arg0), arg1+1);
            SetDBEntry(login, strParam(s:DB_FIELD_WEAPON, d:arg0), 0);
            SetDBEntry(login, strParam(s:DB_FIELD_EXP, d:arg0), 0);
        break;

        /*
        @arg0 slot
        */
        case DB_DELETE_HERO:
            SetDBEntry(login, strParam(s:DB_FIELD_HERO_ID, d:arg0), 0);
        break;
    }

    EndDBTransaction();
}


function void createHero(int player, int slot, int heroId) {
    setPlayerHero(player, slot, heroId);
    setWepUnlocked(player, slot, 0);
	setExp(player, slot, 0);
    if (slot >= 0)
        dbOperation(player, DB_CREATE_HERO, slot, heroId);
}

function void deleteHero(int player, int slot) {
    setPlayerHero(player, slot, -1);
    if (slot >= 0)
        dbOperation(player, DB_DELETE_HERO, slot, 0);
}

function void pukeReply(int responseCode) { GiveInventory("8C Puke Response", responseCode); }
function int pukeStatus(void) { return CheckInventory("8C Puke Response"); }
    
function void loginPoll(int player) {
	if (!isLoggedIn(player)) {
		if (GetCvar(CVAR_AUTOLOGIN)) 
            consolecommand("login");
		ACS_NamedExecuteWithResult("8C Puke", PUKE_LOGIN_REFRESH);
	}
}
    

#DEFINE NET_START_SCREEN 256
#DEFINE START_SCREEN 257
    #DEFINE START_SCREEN_TITLE 1
    #DEFINE START_SCREEN_EXIT 2
    #DEFINE START_SCREEN_OPTIONS 3
    #DEFINE START_SCREEN_CREATE_HERO 4
    #DEFINE START_SCREEN_DATA 5

#DEFINE CLIENT_PUKE 258
#DEFINE HUD_TRANSITION 259

 // /


        #DEFINE __START_SCREEN_CREATE_HERO 6
    #DEFINE START_SCREEN_ENTER_GAME 4

script "8C NET CS" (int type) NET CLIENTSIDE {
	switch(type) {
		case NET_START_SCREEN:
			ACS_NamedExecuteWithResult("8C CS", START_SCREEN);
		break;
	}
}
script "8C CS" (int type, int arg1, int arg2, int arg3) CLIENTSIDE {
	int localPlayer = ConsolePlayerNumber();
    switch(type) {
        case START_SCREEN:
			if (inMenu() | !PlayerIsSpectator(localPlayer))
                terminate; 
            resetMenu();
            ACS_NamedExecuteWithResult("8C CS", HUD_TRANSITION, true,  HUD_ID);
            delay(18);
			LocalSetMusic("8CDATA");
		 	setMenu(START_SCREEN_TITLE);
            setMenuTransition(START_SCREEN_TITLE);
            int i = 0;
            arg2 = getMenuIndex();
            setMenuRefresh(true);
            erase(HUD_ID); erase(HUD_ID+1);
            arg1 = 0x100 | 0x6;
            while (true) {
                if (getMenuTransition()) {
                    // special transition
                    if (getMenuTransition()>>6) { 
                        if (!arg1) 
                            ACS_NamedExecuteWithResult("8C CS", HUD_TRANSITION, true,  HUD_ID);
                        else if (arg1 == 15) {
                            setMenu(getMenuTransition()&0x3F);
                            setMenuIndex(0); setMenuRefresh(true); eraseAll(HUD_ID,16);
                            ACS_NamedExecuteWithResult("8C CS", HUD_TRANSITION, false,  HUD_ID);
                        }
                        else if (arg1 == 30) {
                            setMenuTransition(0);
                            arg1 = 0; continue;
                        }
                        arg1++;
                    }
                    // fadeout transition
                    else {
                        if (arg1>>8) {
                            arg1++;
                            if ((arg1&0xFF) == 7) {
                                setMenu(getMenuTransition());
                                arg1&=0xFF;
                                setMenuIndex(0);    setMenuRefresh(true);   eraseAll(HUD_ID,16);
                                if (getMenuTransition()==START_SCREEN_EXIT) {
                                    draw("8CBLACK", HUD_ID, false, 0, 0,  1, 1, 0.5, 1.0);
                                    delay(8);
                                    break;
                                }
                            }
                        }
                        else if (arg1) {
                            arg1--;
                            if (!arg1) setMenuTransition(0);
                        }  
                        else            arg1 = 0x100;
                        draw("8CBLACK", HUD_ID, false, 0, 0,  1, 1, 0.05, FixedDiv((arg1&0xFF)<<16,7.0));

                    }
                }
                startScreen(HUD_ID+3);
                drawSBI("8CMENU0Q",-160.1+((i*80)&0xFFFF0000), -96.1+((i*96)&0xFFFF0000)); // background
				i = (i-512)&0xFFFF;
                if (getMenuQuery()) {
                    draw("XWMETCU1", HUD_ID, false, 12.1, 139.2, 240, 150, 0.05, 1.0);
                    draw("Waiting for\n\n server...", HUD_ID+1, true, 108.0, 212.2, 368, 230, 0.05, 1.0);
                    draw("8CBLACK", HUD_ID+2, false, 0, 0,  1, 1, 0.05, 0.75);                    
                }
                delay(1);
            }
            ACS_NamedExecuteWithResult("8C CS", HUD_TRANSITION, false, HUD_ID);
			LocalSetMusic("*"); // if8Cmap ...
            delay(16);
            setMenu(0);
        break;

        // arg1 = the server NET script to puke
		// arg2/3 = 2 usable arguments
		case CLIENT_PUKE:
            clearInv("8C Puke Response");
			str pukeDebug = strParam(
				s:"\cdPUKE [net ", d:arg1, 
				s:" - arg1 ", d:arg2, 
				s:" - arg2 ", d:arg3, s:"]"
			);
			log(s:pukeDebug);
			type = 0;
			do {
				NamedRequestScriptPuke("8C Puke", arg1, arg2, arg3);
				delay(1);
				if (type < PUKE_TIMEOUT) 
					int status = pukeStatus();
				else {
                    pukeReply(PUKE_TIMED_OUT);
					status = PUKE_TIMED_OUT;
                }
				type++;
			} while(status == PUKE_WAITING);
			log(s:pukeDebug, s:" --> ", 
				s:( status == PUKE_OK ? "\cvOK" : 
					status == PUKE_ERROR ? "\caERROR" : 
					status == PUKE_SKIPPED ? "\ccSKIPPED" : 
					"\cqTIMED OUT"));
		break;

        case HUD_TRANSITION:
            // fadeout
            if (arg1) { type = 0; localPlayer = 16; arg3 = 1; }
            else { type = 16; localPlayer = 0; arg3 = -1; }
            for (type = type; type != localPlayer; type += arg3) {
                drawBI("8CTITLTR", arg2,    -32.0 + 2.0*type, 8.0, 16, 16);
                drawBI("8CTITLTR", arg2+1,  48.0  - 2.0*type, 9.0, 16, 16);
                delay(1);
            }
        break;
    }    
}


function void printHeroText(int hero, int hudId) {
    drawTypedT(lineBreak(getHeroText(hero),22), hudId, 158.1, 140.1, 400, 250, 0.008);
}

// wtf is this design pattern ? o wo ' -' ' -'XD? ?
#DEFINE TITLE_OFFSET 48.0
function void startScreen(int hudId) {
    int inputStatus = pressedStatus();
    switch(getMenu()) {
        case START_SCREEN_TITLE:
            int player = ConsolePlayerNumber();
            bool isOnline = isNetworkGame();//, logged = isLoggedIn(player);
            int isOnlineOffset = TITLE_OFFSET*isOnline;
            bool logged = isLoggedIn(player);            
            bool isFirstHero = isSlotEmpty(player,0) && isSlotEmpty(player,1);

            if (getMenuRefresh()) {
                drawBI("8CMENU04", hudId, 160.0, 152.0, 320, 350);
                drawBI("8CMENU02", hudId+1, 160.0, 336.0-(TITLE_OFFSET*(!isOnline)), 320, 350);
                // if (isOnline) {
                //     if (logged) {
                //         //  drawTitle(strParam(s:"logged in as ", s:getLogin(player)), -1, false);
                //         drawStartLabel(isFirstHero ? "START" : "CONTINUE", hudId+6, 20.0+isOnlineOffset, !getMenuIndex());
                //     }
                //     else {
                //         drawStartLabel("LOGIN", hudId+6, 20.0+isOnlineOffset, !getMenuIndex());
                //             // 	if (!(Timer()&0x1F)) loginPoll(player);
                //     }
                // }
                // else if (!getMenuIndex())
                //     setMenuIndex(1);
                drawStartLabel("QUICK PLAY", hudId+2, 144.0+isOnlineOffset, getMenuIndex()==1);
                drawStartLabel("OPTIONS",   hudId+5, 144.0+TITLE_OFFSET+isOnlineOffset, getMenuIndex()==2);
                drawStartLabel("BACK TO GAME", hudId+8, 144.0+(TITLE_OFFSET*2)+isOnlineOffset, getMenuIndex()==3);

                // setMenuRefresh(false);
            }

            if(getMenuTransition())
                break;
            else if (isPressed(inputStatus,MENU_NO)) {
                setMenuTransition(START_SCREEN_EXIT);
            }
            else if (isPressed(inputStatus,MENU_DOWN)) {
                if (getMenuIndex()<3) {                    
                    setMenuIndex(getMenuIndex()+1);
                    setMenuRefresh(true);
                }
            }
            else if (isPressed(inputStatus,MENU_UP)) {
                if (getMenuIndex() > !isOnline) {
                    setMenuIndex(getMenuIndex()-1);
                    setMenuRefresh(true);
                }
            }
            else if (isPressed(inputStatus,MENU_YES)) {
                switch(getMenuIndex()) {
                    case 0: 
                        if (isFirstHero) {
                            setMenuArg(0,0);
                            setMenuTransition(START_SCREEN_CREATE_HERO);                            
                        }
                        else setMenuTransition(START_SCREEN_DATA);
                    break;

                    case 1:
                        if (isSlotEmpty(player, -1)) {
                            setMenuArg(0,-1);
                            setMenuTransition(START_SCREEN_CREATE_HERO);                            
                        }
                        else setMenuTransition(START_SCREEN_DATA);
                    break;

                    case 2:
                        setMenuTransition(START_SCREEN_OPTIONS);
                    break;

                    case 3: 
                        setMenuTransition(START_SCREEN_EXIT);
                    break;
                }

            }
        break;

        case START_SCREEN_OPTIONS:
            isOnline = isNetworkGame();//, logged = isLoggedIn(player);
            isOnlineOffset = 40.0*isOnline;
        
            if (getMenuRefresh()) {
                if (isOnline)
                    drawStartLabel(strParam(s:"AUTO LOGIN IS ", s:(GetCvar(CVAR_AUTOLOGIN) ? "\cdon" : "\cgoff")), 
                        hudId+4, 20.0+isOnlineOffset, !getMenuIndex());
                else if (!getMenuIndex())
                    setMenuIndex(1);
                drawStartLabel("KEY BINDS", hudId, 20.0+isOnlineOffset, getMenuIndex()==1);
                drawStartLabel("BACK", hudId+2, 60.0+isOnlineOffset, getMenuIndex()==2);
                setMenuRefresh(false);
            }

            if(getMenuTransition()) 
                break;
            else if (isPressed(inputStatus,MENU_NO)) {
                setMenuTransition(START_SCREEN_TITLE);
            }
            else if (isPressed(inputStatus,MENU_DOWN)) {
                if (getMenuIndex()<2) {
                    setMenuIndex(getMenuIndex()+1);
                    setMenuRefresh(true);
                }
            }
            else if (isPressed(inputStatus,MENU_UP)) {
                if (getMenuIndex()>isOnline) {
                    setMenuIndex(getMenuIndex()-1);                    
                    setMenuRefresh(true);
                }
            }
            else if (isPressed(inputStatus,MENU_YES)) {
                switch(getMenuIndex()) {
                    case 0: 
                        consolecommand(strParam(s:CVAR_AUTOLOGIN, s:" ", d:!GetCvar(CVAR_AUTOLOGIN)));
                        setMenuRefresh(true);
                    break;

                    case 1:
                        log(s:"binder");
                    break;

                    case 2:
                        setMenuTransition(START_SCREEN_TITLE);
                    break;
                }

            }
        break;

        // arg0 slot, arg1 spin status/confirm status, arg2 created confirm animation
        case START_SCREEN_CREATE_HERO:
            int hero = getMenuIndex()&0xFF;
            int index = (getMenuIndex()>>8)&0x1;
            int confirm = (getMenuArg(1)>>8)&0xFF;
            int spinning = getMenuArg(1)&0xFF;
            int n = getHeroSize();
            int created = getMenuArg(2);

            if (getMenuRefresh()) {
                if (!(getMenuRefresh()>>1)) {
                    printHeroText(hero, hudId);

                    drawTypedT(getHeroName(hero), hudId+1, 40.1, 34.1, 240, 150, 0.18);
                    drawBT(lineBreak(getSpSkill(hero),16), hudId+2, 346.6, 102.1, 400, 250);
                    int i = 0;
                    while (true) {
                        draw8cNumber(getHeroWeapons(hero), hudId+8+i, -24.0*i+266.2, 64.2, SMALL_FONT);
                        if ((i+1) >= getHeroWeaponGroups(hero)) break;
                        drawBT("\ck+", hudId+8+i+MAX_WEAPON_GROUPS, -24.0*i+252.2, 62.2, DEFAULT_HUD_X, DEFAULT_HUD_Y);
                        i++;
                    }
                }
                drawStartLabel("Back", hudId+4, 214.1, (index || (confirm==2)));
                drawBI(created ? getHeroSelected(hero) : getHeroIdle(hero), hudId+3, 50.1, 102.1, 200, 125);
                if (confirm)
			        drawStartLabel("Confirm", hudId+6, 183.1, confirm==1);
                else {                    
                    eraseAll(hudId+6,2);
                }
                setMenuRefresh(false);
            }

            if (spinning) {
                drawSBI("8CTITLW1", 160.0, 0.1);                
                if (spinning&0x10)      i = hero+n-1;      // left spin
                else                    i = hero+n;                           // right spin

                int list[4] = { (i-1)%n, i%n, (i+1)%n, (i+2)%n }; // o wo? ?
                drawBI(getHeroMugshot(list[0]), 0, 260.0, 8.1, 640, 400);
                drawBI(getHeroMugshot(list[1]), 0, 295.0, 41.1, 640, 400); 
                drawBI(getHeroMugshot(list[2]), 0, 343.0, 41.1, 640, 400); 
                drawBI(getHeroMugshot(list[3]), 0, 376.0, 8.1, 640, 400); 
            }
            else { 
                drawSBI("8CTITLW0", 160.0, 0.1);
                drawBI(getHeroMugshot((hero+n-2)%n), 0, 256.0, -18.1, 640, 400);
                drawBI(getHeroMugshot((hero+n-1)%n), 0, 274.0, 32.1, 640, 400);
                drawBI(getHeroMugshot(hero), 0, 320.0, 48.1, 640, 400);
                drawBI(getHeroMugshot((hero+1)%n), 0, 366.0, 32.1, 640, 400);
                drawBI(getHeroMugshot((hero+2)%n), 0, 384.0, -18.1, 640, 400);
            }

            
            draw8cBar("8CBARHP", true, 2, 56, 0.5, 56.0, 72.0, 0.9);
            draw8cBar("8CBARPUI", true, 2, 56, 0.25, 56.0, 90.0, 0.9);
            drawBI("8CTITLM5", 0, 148.0, 96.0, 288, 180); // main frame
            drawBI("8CTITLM7", 0, 50.0, 106.0, DEFAULT_HUD_X, DEFAULT_HUD_Y); // avatar bg
            drawBI("8CTITLME", 0, 37.0, 32.0, 288, 180); // top background

            
            if (getMenuQuery()) {   
                switch(pukeStatus()) {
                    case PUKE_OK:
                        //log(s:"return ok");
                        LocalAmbientSound("misc/secret", 127);                              //      o    w o?
                        drawTypedT(lineBreak("       / / / / / / / / / / / / / 0101001001000101010000010100010001011001  / / / / / /               o/   ",22), hudId, 158.1, 140.1, 400, 250, 0.006);
                        setMenuQuery(false);
                        setMenuRefresh(0x3);
                        setMenuArg(2, 1);
                    break;

                    case PUKE_ERROR:
                        //log(s:"\caError when trying to create hero");
                        setMenuQuery(false);
                    break;

                    case PUKE_TIMED_OUT:
                        //log(s:"\cnTimed out.");
                        setMenuQuery(false);
                    break;
                }
            }
            else if (spinning) {
                if ((spinning&0xF) < 4) setMenuArg(1, getMenuArg(1)+1);
                else {
                    setMenuIndex((getMenuIndex()&0xFFFFFF00) | 
                        spinning&0x10 ? ((hero+n-1) % n) : ((hero+1)%n));
                    setMenuArg(1, getMenuArg(1)&0xFFFFFF00);
                    setMenuRefresh(true);
                } 
            }            
            else if (created && !getMenuTransition()) {
                setMenuArg(2,getMenuArg(2)+1);
                if ((timer()&0x1) && (created<22))
                    draw("8CWHITE", hudId-1, false, 0, 0,  1, 1, 0.05, 0.35);
                
                if (created>35) {
                    setMenuTransition(0xC0 | START_SCREEN_DATA);
                    setMenuArg(0,0); setMenuArg(1,0); setMenuArg(2,0);
                }
            }         
            else if (getMenuTransition() | getMenuQuery() | created) 
                break;

            else if (isPressed(inputStatus, MENU_NO)) {
                if (confirm) {                    
                    setMenuArg(1, getMenuArg(1)&0xFFFF00FF);
                    setMenuRefresh(0x3);
                    printHeroText(hero, hudId);
                }
                else setMenuTransition(START_SCREEN_TITLE);    
            }
            else if (isPressed(inputStatus, MENU_DOWN)) {
                if (confirm) {
                    if (confirm==1) {
                        setMenuArg(1, getMenuArg(1)+(1<<8));
                        setMenuRefresh(0x3);
                    }
                }
                else if (!index) {                    
                    setMenuIndex(getMenuIndex()+0x100);
                    setMenuRefresh(0x3);
                }
            }
            else if (isPressed(inputStatus, MENU_UP)) {
                if (confirm) {
                    if (confirm==2) {
                        setMenuArg(1, getMenuArg(1)-(1<<8));
                        setMenuRefresh(0x3);
                    } 
                }
                else if (index) {
                    setMenuIndex(getMenuIndex()-0x100);
                    setMenuRefresh(0x3);
                }
            }
            else if (isPressed(inputStatus,MENU_LEFT) && !(index|confirm))
                setMenuArg(1,0x11);
            else if (isPressed(inputStatus,MENU_RIGHT) && !(index|confirm))
                setMenuArg(1,0x1);
            else if (isPressed(inputStatus,MENU_YES)) {
                if (confirm) {
                    if (confirm==1) {
                        ACS_NamedExecuteWithResult("8C CS", CLIENT_PUKE, PUKE_HERO_CREATE, getMenuArg(0), hero);
                        setMenuQuery(true);
                    }
                    else {
                        setMenuArg(1, getMenuArg(1)&0xFFFF00FF);
                        setMenuRefresh(0x3);
                        printHeroText(hero, hudId);
                    }
                }
                else {
                    if (!index) {
                        setMenuArg(1, getMenuArg(1) | (1<<8));
                        drawTypedT(lineBreak(strParam(s:"Start game with\n\n    ", s:getHeroName(hero), s:"?") ,50), hudId, 158.1, 140.1, 400, 250, 0.015);    
                        setMenuRefresh(0x3);                

                    }
                    else {
                        setMenuTransition(START_SCREEN_TITLE);

                    }
                }
            }
        break;

        case START_SCREEN_DATA:
            n = getMenuArg(0) ? MAX_SLOTS : 1;
            //index = (getMenuIndex()>>8)&0x1;
            player = ConsolePlayerNumber();
            if (getMenuRefresh()) {
                drawStartLabel("Back", hudId, 214.1, getMenuIndex()==n);
                for (i = 0; i < n; i++) { // i = slot
                    int slot = getMenuArg(0) ? i : -1;
                    hero = getPlayerHero(player, slot);
                    drawBI(getHeroIdle(hero),                       (hudId+2), 50.1, 50.1, 200, 125);
                    drawTypedT(getHeroName(hero),                   (hudId+3), 80.1, 30.1, 200, 125, 0.05);

                    drawBT("Rank",                                  (hudId+4), 120.1, 56.1, 320, 200);                    
                    draw8cNumber(expToRank(getExp(hero, slot)),     (hudId+5), 160.1, 56.1, SMALL_FONT);
                }
                setMenuRefresh(false);
            }
            
            if (isPressed(inputStatus, MENU_NO)) {
                setMenuTransition(START_SCREEN_TITLE);    
            }
            else if (isPressed(inputStatus, MENU_DOWN)) {
                if (getMenuIndex()<n) {                    
                    setMenuIndex(getMenuIndex()+1);
                    setMenuRefresh(true);
                }
            }
            else if (isPressed(inputStatus, MENU_UP)) {
                if (getMenuIndex()>0) {                    
                    setMenuIndex(getMenuIndex()-1);
                    setMenuRefresh(true);
                }
            }
            else if (isPressed(inputStatus,MENU_YES)) {
                if (getMenuIndex() == n) {
                    setMenuTransition(START_SCREEN_TITLE);
                }
            }
        break;
    }
}


function void drawStartLabel(str label, int id, int y, bool isSelected) {
	drawBI("8CMENU08", id, 160.0, y+24.0, 320, 350);
    drawBT(strParam(s:"\cc", s:label), id+1, 160.0, (FixedMul(y,0.763)&0xFFFF0000) + 22.0, 320, 270);
	drawBI(strParam(s: !isSelected ? "8CMENU06" : "8CMENU07"), id+2, 104.0, y, 320, 350);
}

function int expToRank(int exp) { return 1 + (exp/50); }
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    //////////////////////////////////////////////////////////
//                           Misc/utils            				//
	//////////////////////////////////////////////////////////

function int ceilf(int n) { return ((n-1) & 0xFFFF0000) + 1.0; }
function int floorf(int n) { return n&0xFFFF0000; }
function int roundf(int n) { return (n+0.5)&0xFFFF0000; }
    
function int getBit(int x, int b) { return (x & (1 << b))>>b; }
function int bitOn(int x, int b) { return x | (1 << b); }
function int bitOff(int x, int b) { return x & ~(1 << b); }

// 16 values of [2 bits]
function int get2bFlagVal(str cvar, bool incrCvar,  int var) 			{ return __getNbitFlagVal(cvar, incrCvar, var, 0xF, 4, 0xFFFF); }
function void set2bFlagVal(str cvar, bool incrCvar, int var, int val) { __setNbitFlagVal(cvar, incrCvar, var, 0xF, 4, 0xFFFF, val); }

// 8 values of [4 bits]
function int get4bFlagVal(str cvar, bool incrCvar, int var) 			{ return __getNbitFlagVal(cvar, incrCvar, var, 0x7, 3, 0xFF); }
function void set4bFlagVal(str cvar, bool incrCvar, int var, int val) 	{ __setNbitFlagVal(cvar, incrCvar, var, 0x7, 3, 0xFF, val); }

// 4 values of [8 bits]
function int get8bFlagVal(str cvar, bool incrCvar, int var) 			{ return __getNbitFlagVal(cvar, incrCvar, var, 0x3, 2, 0xF); } 
function void set8bFlagVal(str cvar, bool incrCvar, int var, int val) 	{ __setNbitFlagVal(cvar, incrCvar, var, 0x3, 2, 0xF, val); }

// 2 values of [16 bits]
function int get16bFlagVal(str cvar, bool incrCvar, int var) 				{ return __getNbitFlagVal(cvar, incrCvar, var, 0x1, 1, 0x7); }
function void set16bFlagVal(str cvar, bool incrCvar, int var, int val) 	{ __setNbitFlagVal(cvar, incrCvar, var, 0x1, 1, 0x7, val); }

function int __getNbitFlagVal(str cvar, bool incrCvar, int var, int n, int log2n, int mask) {
	n = (var&n)<<log2n;
	return ((GetCvar(incrCvar ? strParam(s:cvar, d:var>>log2n) : cvar) & (mask<<n))>>n)&mask; // "woaaah my head is spinning"
}

function void __setNbitFlagVal(str cvar, bool incrCvar, int var, int n, int log2n, int mask, int val) {
	if (incrCvar)
		cvar = strParam(s:cvar, d:var>>log2n);
	n = (var&n)<<log2n;
	SetCVar(cvar,  (GetCvar(cvar) & ~(mask<<n)) | (val<<n));		
}

function int valueOr(int object, int or) {
	if (object) return object;
	return or;
}

// the str returned by GetCvarString can cause issues when the Cvar requested doesn't exist
function str strSanitize(str string) {
	return valueOr(string,"");
}

function void clearInv(str item) { 
	TakeInventory(item,INT_MAX);
}

// general HUD draw wrapper / to call from clientside
function void draw(str data, int id, bool isText, int x, int y, int xScreen, int yScreen, int time, int alpha) {
	SetHudSize(xScreen,yScreen,true); 	
	if (isText) {
		SetFont("CONFONT");
		int val = data;
	}
	else {
		SetFont(data); 
        val="A";
	}
	HudMessageBold(s:val;((alpha>>24) ? HUDMSG_TYPEON : HUDMSG_PLAIN)|HUDMSG_ALPHA ,id,CR_UNTRANSLATED,x,y,time,alpha&0x1FFFF,0.0);
}

// basic version
function void drawBI(str image, int id, int x, int y, int xScreen, int yScreen) { 
    draw(image, valueOr(id,Get_And_Inc_AssistDisplayID()), false, x, y, xScreen, yScreen, (id ? 32000.0 : 0.04), 1.0); }
function void drawBT(str text, int id, int x, int y, int xScreen, int yScreen) { 
    draw(text, valueOr(id,Get_And_Inc_AssistDisplayID()), true, x, y, xScreen, yScreen, (id ? 32000.0 : 0.04), 1.0); }
function void drawTypedT(str text, int id, int x, int y, int xScreen, int yScreen, int typeTime) {  
    draw(text, id, true, x, y, xScreen, yScreen, 32000.0, typeTime|0x1000000); }

// super basic version
function void drawSBI(str image, int x, int y) { draw(image, Get_And_Inc_AssistDisplayID(), false, x, y, DEFAULT_HUD_X, DEFAULT_HUD_Y, 0.04, 1.0); }
function void drawSBT(str text, int x, int y) { draw(text, Get_And_Inc_AssistDisplayID(), true, x, y, DEFAULT_HUD_X, DEFAULT_HUD_Y, 0.04, 1.0); }


function void erase(int id) { HudMessageBold(s:"";0,id,0,0,0,0); }
function void eraseAll(int start, int size) {
    for (int i = start; i < start+size; i++) erase(i);
}

/*
@unit size of each generated part increment, in pixel
@barSize graphic size in pixel when it is fully filled
@fillRatio [0,1.0]

maybe generalize to "draw mask" later
*/
#DEFINE C8_BAR_X 240.0
#DEFINE C8_BAR_Y 190.0
#DEFINE C8_VAR_X 250.0
#DEFINE C8_VAR_Y 180.0

function void draw8cBar(str graphic, bool isHorizontal, int unit, int barSize, int fillRatio, int x, int y, int zoom) {
    int n = ((ceilf((1.0-fillRatio)*(barSize/unit)))>>16); // 28
    int base = n;
    unit<<=16;
    if (isHorizontal) {
        x = (x&0xFFFF0000) | 0.1;
        int end = x+(barSize<<16)+0.1;
        int yZoom = FixedDiv(C8_BAR_Y,zoom)>>16;
        zoom = FixedDiv(C8_BAR_X,zoom)>>16;
        while (n>>4) {  drawBI("8CBARMK2", 0, end-(unit*(base-n)), y, zoom, yZoom); n-=16; }
        while (n>>2) {  drawBI("8CBARMK1", 0, end-(unit*(base-n)), y, zoom, yZoom); n-=4;  }
        while (n)    {  drawBI("8CBARMK0", 0, end-(unit*(base-n)), y, zoom, yZoom); n--;   }
        drawBI(graphic, 0, x, y, zoom, yZoom);
    }
    else {
        y = (y&0xFFFF0000) | 0.2;
        end = y-(barSize<<16)-0.1;
        yZoom = FixedDiv(C8_VAR_Y,zoom)>>16;
        zoom = FixedDiv(C8_VAR_X,zoom)>>16;
        while (n>>4) {  drawBI("8CVARMK2", 0, x, end+(unit*(base-n)), zoom, yZoom); n-=16; }
        while (n>>2) {  drawBI("8CVARMK1", 0, x, end+(unit*(base-n)), zoom, yZoom); n-=4;  }
        while (n)    {  drawBI("8CVARMK0", 0, x, end+(unit*(base-n)), zoom, yZoom); n--;   }
        drawBI(graphic, 0, x, y, zoom, yZoom);
    }
}

// drawn right to left
function void draw8cNumber(int number, int id, int x, int y, int font) {
	switch(font) {
		case SMALL_FONT: int space = 11.0; break;
		case BIG_FONT: space = 14.0; break;
	}
	font = strParam(s:"8CNUMB",d:font);
	int dx = 0;
	while (true) {
		int digit = number%10;
        if (!id)
		    drawSBI(strParam(s:font, d:digit), x+ (space*dx), y);
        else
            drawBI(strParam(s:font, d:digit), id-dx, x+ (space*dx), y, DEFAULT_HUD_X, DEFAULT_HUD_Y);
        
        number /= 10;
        if (!number) break;
		else break;
		dx--;
	}
}


function int pressedStatus(void) {
    int prev = GetPlayerInput(-1, INPUT_OLDBUTTONS);
    return (GetPlayerInput(-1, INPUT_BUTTONS) ^ prev) & ~prev;
}
function bool isPressed(int status, int key) {
	return (status&key);
}


function str lineBreak(str string, int every) {
    str s = "";
    int length = strLen(string);
    while (length>0) {
        s = strParam(s:s, s:strLeft(string, every), s:"\n");
        length-=every;
        string = strRight(string, length);
    }
    return s;
}




	//////////////////////////////////////////////////////////
//                           debug/playground/temporary code   //
	//////////////////////////////////////////////////////////


// /* ALIGNER
// x
// .0 = positions center of box
// .1 = positions left edge of box
// .2 = positions right edge of box
// .4 = centers text inside box and aligns center
// .5 = centers text and aligns left edge
// .6 = centers text and aligns right edge
// For y:

// .0 = positions center of box
// .1 = positions top edge of box
// .2 = positions bottom edge of box*/
